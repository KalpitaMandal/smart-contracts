{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nstruct BigInt {\n    bytes val;\n    bool neg;\n}\n\nlibrary BigIntCBOR {\n    function serializeBigNum(BigInt memory num) internal pure returns (bytes memory) {\n        // TODO improve gas efficiency by using assembly code\n        bytes memory raw = new bytes(num.val.length + 1);\n\n        if (num.neg) {\n            raw[0] = 0x01;\n        }\n\n        uint index = 1;\n        for (uint i = 0; i < num.val.length; i++) {\n            raw[index] = num.val[i];\n            index++;\n        }\n\n        return raw;\n    }\n\n    function deserializeBigInt(bytes memory raw) internal pure returns (BigInt memory) {\n        // TODO improve gas efficiency by using assembly code\n\n        // Is an empty byte a valid BigInt ? We should have the sign byte at least\n        if (raw.length == 0) {\n            return BigInt(hex\"00\", false);\n        }\n\n        bytes memory val = new bytes(raw.length - 1);\n        bool neg = false;\n\n        if (raw[0] == 0x01) {\n            neg = true;\n        }\n\n        for (uint i = 1; i < raw.length; i++) {\n            val[i - 1] = raw[i];\n        }\n\n        return BigInt(val, neg);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {MarketTypes} from \"../types/MarketTypes.sol\";\nimport \"./BigIntCbor.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary WithdrawBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.provider_or_client);\n        buf.writeBytes(params.tokenAmount.serializeBigNum());\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.amount_withdrawn = tmp.deserializeBigInt();\n    }\n}\n\nlibrary AddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n}\n\nlibrary GetBalanceCBOR {\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.locked = tmp.deserializeBigInt();\n    }\n}\n\nlibrary GetDealDataCommitmentCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealDataCommitmentReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n\n        if (len > 0) {\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n    }\n}\n\nlibrary GetDealClientCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealClientReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.client, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealProviderCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealProviderReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.provider, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealLabelCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealLabelReturn memory ret, bytes memory rawResp) internal pure {\n        string memory label;\n        uint byteIdx = 0;\n\n        (label, byteIdx) = rawResp.readString(byteIdx);\n\n        ret.label = label;\n    }\n}\n\nlibrary GetDealTermCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealTermReturn memory ret, bytes memory rawResp) internal pure {\n        int64 start;\n        int64 end;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (start, byteIdx) = rawResp.readInt64(byteIdx);\n        (end, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.start = start;\n        ret.end = end;\n    }\n}\n\nlibrary GetDealEpochPriceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetDealEpochPriceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.price_per_epoch = tmp.deserializeBigInt();\n    }\n}\n\nlibrary GetDealClientCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetDealClientCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigInt();\n    }\n}\n\nlibrary GetDealProviderCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetDealProviderCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigInt();\n    }\n}\n\nlibrary GetDealVerifiedCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealVerifiedReturn memory ret, bytes memory rawResp) internal pure {\n        bool verified;\n        uint byteIdx = 0;\n\n        (verified, byteIdx) = rawResp.readBool(byteIdx);\n\n        ret.verified = verified;\n    }\n}\n\nlibrary GetDealActivationCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MarketTypes.GetDealActivationReturn memory ret, bytes memory rawResp) internal pure {\n        int64 activated;\n        int64 terminated;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (activated, byteIdx) = rawResp.readInt64(byteIdx);\n        (terminated, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.activated = activated;\n        ret.terminated = terminated;\n    }\n}\n\nlibrary PublishStorageDealsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.deals.length));\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            buf.startFixedArray(11);\n\n            buf.writeBytes(params.deals[i].proposal.piece_cid);\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\n            buf.writeBool(params.deals[i].proposal.verified_deal);\n            buf.writeBytes(params.deals[i].proposal.client);\n            buf.writeBytes(params.deals[i].proposal.provider);\n            buf.writeString(params.deals[i].proposal.label);\n            buf.writeInt64(params.deals[i].proposal.start_epoch);\n            buf.writeInt64(params.deals[i].proposal.end_epoch);\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigNum());\n\n            buf.writeBytes(params.deals[i].client_signature);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.PublishStorageDealsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.ids = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\nlibrary DealIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(uint64 id) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(id);\n\n        return buf.data();\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/MinerCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {MinerTypes} from \"../types/MinerTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ChangeBeneficiaryCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MinerTypes.ChangeBeneficiaryParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(3);\n        buf.writeBytes(params.new_beneficiary);\n        buf.writeBytes(params.new_quota.serializeBigNum());\n        buf.writeUInt64(params.new_expiration);\n\n        return buf.data();\n    }\n}\n\nlibrary GetOwnerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetOwnerReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.owner, byteIdx) = rawResp.readBytes(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (ret.proposed, byteIdx) = rawResp.readBytes(byteIdx);\n        }\n    }\n}\n\nlibrary IsControllingAddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.IsControllingAddressReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.is_controlling, byteIdx) = rawResp.readBool(byteIdx);\n    }\n}\n\nlibrary GetSectorSizeCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetSectorSizeReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.sector_size, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetAvailableBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetAvailableBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.available_balance = tmp.deserializeBigInt();\n        } else {\n            ret.available_balance = BigInt(new bytes(0), false);\n        }\n    }\n}\n\nlibrary AddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n}\n\nlibrary GetBeneficiaryCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetBeneficiaryReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.active.beneficiary, byteIdx) = rawResp.readBytes(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.quota = tmp.deserializeBigInt();\n        } else {\n            ret.active.term.quota = BigInt(new bytes(0), false);\n        }\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.used_quota = tmp.deserializeBigInt();\n        } else {\n            ret.active.term.used_quota = BigInt(new bytes(0), false);\n        }\n\n        (ret.active.term.expiration, byteIdx) = rawResp.readUInt64(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 5);\n\n            (ret.proposed.new_beneficiary, byteIdx) = rawResp.readBytes(byteIdx);\n\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                ret.proposed.new_quota = tmp.deserializeBigInt();\n            } else {\n                ret.proposed.new_quota = BigInt(new bytes(0), false);\n            }\n\n            (ret.proposed.new_expiration, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.proposed.approved_by_beneficiary, byteIdx) = rawResp.readBool(byteIdx);\n            (ret.proposed.approved_by_nominee, byteIdx) = rawResp.readBool(byteIdx);\n        }\n    }\n}\n\nlibrary GetVestingFundsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetVestingFundsReturn memory ret, bytes memory rawResp) internal pure {\n        int64 epoch;\n        BigInt memory amount;\n        bytes memory tmp;\n\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.vesting_funds = new CommonTypes.VestingFunds[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (epoch, byteIdx) = rawResp.readInt64(byteIdx);\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n\n            amount = tmp.deserializeBigInt();\n            ret.vesting_funds[i] = CommonTypes.VestingFunds(epoch, amount);\n        }\n    }\n}\n\nlibrary ChangeWorkerAddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangeWorkerAddressParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.new_worker);\n        buf.startFixedArray(uint64(params.new_control_addresses.length));\n\n        for (uint64 i = 0; i < params.new_control_addresses.length; i++) {\n            buf.writeBytes(params.new_control_addresses[i]);\n        }\n\n        return buf.data();\n    }\n}\n\nlibrary ChangePeerIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangePeerIDParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.new_id);\n\n        return buf.data();\n    }\n}\n\nlibrary ChangeMultiaddrsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangeMultiaddrsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.new_multi_addrs.length));\n\n        for (uint64 i = 0; i < params.new_multi_addrs.length; i++) {\n            buf.writeBytes(params.new_multi_addrs[i]);\n        }\n\n        return buf.data();\n    }\n}\n\nlibrary GetPeerIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetPeerIDReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        (ret.peer_id, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\nlibrary GetMultiaddrsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetMultiaddrsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.multi_addrs = new bytes[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.multi_addrs[i], byteIdx) = rawResp.readBytes(byteIdx);\n        }\n    }\n}\n\nlibrary WithdrawBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.amount_requested);\n\n        return buf.data();\n    }\n\n    function deserialize(MinerTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.amount_withdrawn, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MarketTypes.sol\";\nimport \"./cbor/MarketCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MarketAPI {\n    using AddressCBOR for bytes;\n    using DealIDCBOR for uint64;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    function addBalance(bytes memory provider_or_client) internal {\n        bytes memory raw_request = provider_or_client.serializeAddress();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.AddBalanceMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (MarketTypes.WithdrawBalanceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.WithdrawBalanceMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.WithdrawBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(bytes memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetBalanceMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    function getDealDataCommitment(uint64 dealID) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealDataCommitmentMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealDataCommitmentReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client of a deal proposal.\n    function getDealClient(uint64 dealID) internal returns (MarketTypes.GetDealClientReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealClientMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider of a deal proposal.\n    function getDealProvider(uint64 dealID) internal returns (MarketTypes.GetDealProviderReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealProviderMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the label of a deal proposal.\n    function getDealLabel(uint64 dealID) internal returns (MarketTypes.GetDealLabelReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealLabelMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealLabelReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(uint64 dealID) internal returns (MarketTypes.GetDealTermReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealTermMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealTermReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(uint64 dealID) internal returns (MarketTypes.GetDealEpochPriceReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealEpochPriceMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealEpochPriceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(uint64 dealID) internal returns (MarketTypes.GetDealClientCollateralReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealClientCollateralMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(uint64 dealID) internal returns (MarketTypes.GetDealProviderCollateralReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealProviderCollateralMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function getDealVerified(uint64 dealID) internal returns (MarketTypes.GetDealVerifiedReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealVerifiedMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealVerifiedReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(uint64 dealID) internal returns (MarketTypes.GetDealActivationReturn memory) {\n        bytes memory raw_request = dealID.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealActivationMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealActivationReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(\n        MarketTypes.PublishStorageDealsParams memory params\n    ) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.PublishStorageDealsMethodNum,\n            MarketTypes.ActorID,\n            raw_request,\n            Misc.CBOR_CODEC,\n            msg.value\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.PublishStorageDealsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/MinerAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MinerTypes.sol\";\nimport \"./cbor/MinerCbor.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @notice During miner initialization, a miner actor is created on the chain, and this actor gives the miner its ID f0.... The miner actor is in charge of collecting all the payments sent to the miner.\n/// @dev For more info about the miner actor, please refer to https://lotus.filecoin.io/storage-providers/operate/addresses/\n/// @author Zondax AG\nlibrary MinerAPI {\n    using ChangeBeneficiaryCBOR for MinerTypes.ChangeBeneficiaryParams;\n    using GetOwnerCBOR for MinerTypes.GetOwnerReturn;\n    using AddressCBOR for bytes;\n    using IsControllingAddressCBOR for MinerTypes.IsControllingAddressReturn;\n    using GetSectorSizeCBOR for MinerTypes.GetSectorSizeReturn;\n    using GetAvailableBalanceCBOR for MinerTypes.GetAvailableBalanceReturn;\n    using GetVestingFundsCBOR for MinerTypes.GetVestingFundsReturn;\n    using GetBeneficiaryCBOR for MinerTypes.GetBeneficiaryReturn;\n    using ChangeWorkerAddressCBOR for MinerTypes.ChangeWorkerAddressParams;\n    using ChangePeerIDCBOR for MinerTypes.ChangePeerIDParams;\n    using ChangeMultiaddrsCBOR for MinerTypes.ChangeMultiaddrsParams;\n    using GetPeerIDCBOR for MinerTypes.GetPeerIDReturn;\n    using GetMultiaddrsCBOR for MinerTypes.GetMultiaddrsReturn;\n    using WithdrawBalanceCBOR for MinerTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MinerTypes.WithdrawBalanceReturn;\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @param target The miner address (type ID) you want to interact with\n    /// @return the owner address of a Miner\n    function getOwner(bytes memory target) internal returns (MinerTypes.GetOwnerReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetOwnerMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetOwnerReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function changeOwnerAddress(bytes memory target, bytes memory addr) internal {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeOwnerAddressMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param addr The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function isControllingAddress(bytes memory target, bytes memory addr) internal returns (MinerTypes.IsControllingAddressReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MinerTypes.IsControllingAddressMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.IsControllingAddressReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the miner's sector size.\n    /// @param target The miner address (type ID) you want to interact with\n    /// @dev For more information about sector sizes, please refer to https://spec.filecoin.io/systems/filecoin_mining/sector/#section-systems.filecoin_mining.sector\n    function getSectorSize(bytes memory target) internal returns (MinerTypes.GetSectorSizeReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetSectorSizeMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetSectorSizeReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function getAvailableBalance(bytes memory target) internal returns (MinerTypes.GetAvailableBalanceReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetAvailableBalanceMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetAvailableBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function getVestingFunds(bytes memory target) internal returns (MinerTypes.GetVestingFundsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetVestingFundsMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetVestingFundsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function changeBeneficiary(bytes memory target, MinerTypes.ChangeBeneficiaryParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeBeneficiaryMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function getBeneficiary(bytes memory target) internal returns (MinerTypes.GetBeneficiaryReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetBeneficiaryMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetBeneficiaryReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changeWorkerAddress(bytes memory target, MinerTypes.ChangeWorkerAddressParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeWorkerAddressMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changePeerId(bytes memory target, MinerTypes.ChangePeerIDParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangePeerIDMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changeMultiaddresses(bytes memory target, MinerTypes.ChangeMultiaddrsParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeMultiaddrsMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function repayDebt(bytes memory target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.RepayDebtMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function confirmChangeWorkerAddress(bytes memory target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(\n            MinerTypes.ConfirmChangeWorkerAddressMethodNum,\n            target,\n            raw_request,\n            Misc.NONE_CODEC,\n            msg.value\n        );\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function getPeerId(bytes memory target) internal returns (MinerTypes.GetPeerIDReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetPeerIDMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetPeerIDReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function getMultiaddresses(bytes memory target) internal returns (MinerTypes.GetMultiaddrsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetMultiaddrsMethodNum, target, raw_request, Misc.NONE_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetMultiaddrsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param params the amount you want to withdraw\n    function withdrawBalance(\n        bytes memory target,\n        MinerTypes.WithdrawBalanceParams memory params\n    ) internal returns (MinerTypes.WithdrawBalanceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.WithdrawBalanceMethodNum, target, raw_request, Misc.CBOR_CODEC, msg.value);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.WithdrawBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/SendAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title TODO complete me\n/// @author Zondax AG\nlibrary SendAPI {\n    /// @notice TODO fill this a proper description\n    function send(bytes memory toAddress, uint256 amount) internal {\n        bytes memory rawResponse = Actor.call(0, toAddress, new bytes(0), Misc.NONE_CODEC, amount);\n\n        Actor.readRespData(rawResponse);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    enum RegisteredSealProof {\n        StackedDRG2KiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        StackedDRG2KiBV1P1,\n        StackedDRG512MiBV1P1,\n        StackedDRG8MiBV1P1,\n        StackedDRG32GiBV1P1,\n        StackedDRG64GiBV1P1,\n        Invalid\n    }\n\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n\n    enum RegisteredUpdateProof {\n        StackedDRG2KiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        Invalid\n    }\n    enum ExtensionKind {\n        ExtendCommittmentLegacy,\n        ExtendCommittment\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n\n    struct ValidatedExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct ExtendExpirationsInner {\n        ValidatedExpirationExtension[] extensions;\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\n    }\n\n    struct PendingBeneficiaryChange {\n        bytes new_beneficiary;\n        BigInt new_quota;\n        uint64 new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    struct BeneficiaryTerm {\n        BigInt quota;\n        BigInt used_quota;\n        uint64 expiration;\n    }\n\n    struct ActiveBeneficiary {\n        bytes beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    struct RecoveryDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct FaultDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct TerminationDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct SectorClaim {\n        uint64 sector_number;\n        uint64[] maintain_claims;\n        uint64[] drop_claims;\n    }\n\n    struct ExpirationExtension2 {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        SectorClaim[] sectors_with_claims;\n        int64 new_expiration;\n    }\n\n    struct ExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct SectorPreCommitInfoInner {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n\n    struct SectorPreCommitInfo {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n    struct ReplicaUpdateInner {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64[] deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate2 {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct PoStPartition {\n        uint64 index;\n        int8 skipped;\n    }\n\n    struct PoStProof {\n        RegisteredPoStProof post_proof;\n        bytes proof_bytes;\n    }\n\n    struct VestingFunds {\n        int64 epoch;\n        BigInt amount;\n    }\n    struct SectorDeals {\n        int64 sector_type;\n        int64 sector_expiry;\n        uint64[] deal_ids;\n    }\n\n    struct DealProposal {\n        bytes piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        bytes client;\n        bytes provider;\n        string label;\n        int64 start_epoch;\n        int64 end_epoch;\n        BigInt storage_price_per_epoch;\n        BigInt provider_collateral;\n        BigInt client_collateral;\n    }\n\n    struct ClientDealProposal {\n        DealProposal proposal;\n        bytes client_signature;\n    }\n\n    struct SectorDealData {\n        bytes commd;\n    }\n\n    struct CID {\n        uint8 version;\n        uint64 codec;\n        Multihash hash;\n    }\n\n    struct Multihash {\n        uint64 code;\n        uint8 size;\n        bytes digest;\n    }\n\n    struct VerifiedDealInfo {\n        uint64 client;\n        uint64 allocation_id;\n        bytes data;\n        uint64 size;\n    }\n\n    struct SectorDataSpec {\n        uint64[] deal_ids;\n        int64 sector_type;\n    }\n\n    struct FailCode {\n        uint32 idx;\n        uint32 code;\n    }\n\n    struct BatchReturn {\n        // Total successes in batch\n        uint32 success_count;\n        // Failure code and index for each failure in batch\n        FailCode[] fail_codes;\n    }\n\n    struct Claim {\n        // The provider storing the data (from allocation).\n        uint64 provider;\n        // The client which allocated the DataCap (from allocation).\n        uint64 client;\n        // Identifier of the data committed (from allocation).\n        bytes data;\n        // The (padded) size of data (from allocation).\n        uint64 size;\n        // The min period after term_start which the provider must commit to storing data\n        int64 term_min;\n        // The max period after term_start for which provider can earn QA-power for the data\n        int64 term_max;\n        // The epoch at which the (first range of the) piece was committed.\n        int64 term_start;\n        // ID of the provider's sector in which the data is committed.\n        uint64 sector;\n    }\n    struct ClaimTerm {\n        uint64 provider;\n        uint64 claim_id;\n        int64 term_max;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    bytes constant ActorID = hex\"0005\";\n    uint constant AddBalanceMethodNum = 822473126;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n    uint constant GetBalanceMethodNum = 726108461;\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\n    uint constant GetDealClientMethodNum = 128053329;\n    uint constant GetDealProviderMethodNum = 935081690;\n    uint constant GetDealLabelMethodNum = 46363526;\n    uint constant GetDealTermMethodNum = 163777312;\n    uint constant GetDealEpochPriceMethodNum = 4287162428;\n    uint constant GetDealClientCollateralMethodNum = 200567895;\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\n    uint constant GetDealVerifiedMethodNum = 2627389465;\n    uint constant GetDealActivationMethodNum = 2567238399;\n    uint constant PublishStorageDealsMethodNum = 2236929350;\n\n    struct WithdrawBalanceParams {\n        bytes provider_or_client;\n        BigInt tokenAmount;\n    }\n\n    struct WithdrawBalanceReturn {\n        BigInt amount_withdrawn;\n    }\n\n    struct GetBalanceReturn {\n        BigInt balance;\n        BigInt locked;\n    }\n\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    struct GetDealClientReturn {\n        uint64 client;\n    }\n\n    struct GetDealProviderReturn {\n        uint64 provider;\n    }\n\n    struct GetDealLabelReturn {\n        string label;\n    }\n\n    struct GetDealTermReturn {\n        int64 start;\n        int64 end;\n    }\n\n    struct GetDealEpochPriceReturn {\n        BigInt price_per_epoch;\n    }\n\n    struct GetDealClientCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealProviderCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealVerifiedReturn {\n        bool verified;\n    }\n\n    struct GetDealActivationReturn {\n        int64 activated;\n        int64 terminated;\n    }\n\n    struct PublishStorageDealsParams {\n        CommonTypes.ClientDealProposal[] deals;\n    }\n\n    struct PublishStorageDealsReturn {\n        uint64[] ids;\n        bytes valid_deals;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/MinerTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin miner actor types for Solidity.\n/// @author Zondax AG\nlibrary MinerTypes {\n    uint constant GetOwnerMethodNum = 3275365574;\n    uint constant ChangeOwnerAddressMethodNum = 1010589339;\n    uint constant IsControllingAddressMethodNum = 348244887;\n    uint constant GetSectorSizeMethodNum = 3858292296;\n    uint constant GetAvailableBalanceMethodNum = 4026106874;\n    uint constant GetVestingFundsMethodNum = 1726876304;\n    uint constant ChangeBeneficiaryMethodNum = 1570634796;\n    uint constant GetBeneficiaryMethodNum = 4158972569;\n    uint constant ChangeWorkerAddressMethodNum = 3302309124;\n    uint constant ChangePeerIDMethodNum = 1236548004;\n    uint constant ChangeMultiaddrsMethodNum = 1063480576;\n    uint constant RepayDebtMethodNum = 3665352697;\n    uint constant ConfirmChangeWorkerAddressMethodNum = 2354970453;\n    uint constant GetPeerIDMethodNum = 2812875329;\n    uint constant GetMultiaddrsMethodNum = 1332909407;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n\n    struct GetOwnerReturn {\n        bytes owner;\n        bytes proposed;\n    }\n\n    struct IsControllingAddressParam {\n        bytes addr;\n    }\n\n    struct IsControllingAddressReturn {\n        bool is_controlling;\n    }\n\n    struct GetSectorSizeReturn {\n        uint64 sector_size;\n    }\n    struct GetAvailableBalanceReturn {\n        BigInt available_balance;\n    }\n\n    struct GetVestingFundsReturn {\n        CommonTypes.VestingFunds[] vesting_funds;\n    }\n\n    struct ChangeBeneficiaryParams {\n        bytes new_beneficiary;\n        BigInt new_quota;\n        uint64 new_expiration;\n    }\n\n    struct GetBeneficiaryReturn {\n        CommonTypes.ActiveBeneficiary active;\n        CommonTypes.PendingBeneficiaryChange proposed;\n    }\n\n    struct ChangeWorkerAddressParams {\n        bytes new_worker;\n        bytes[] new_control_addresses;\n    }\n\n    struct ChangePeerIDParams {\n        bytes new_id;\n    }\n\n    struct ChangeMultiaddrsParams {\n        bytes[] new_multi_addrs;\n    }\n\n    struct GetPeerIDReturn {\n        bytes peer_id;\n    }\n\n    struct GetMultiaddrsReturn {\n        bytes[] multi_addrs;\n    }\n\n    struct WithdrawBalanceParams {\n        bytes amount_requested;\n    }\n\n    struct WithdrawBalanceReturn {\n        bytes amount_withdrawn;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Actor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./Misc.sol\";\n\nlibrary Actor {\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\n    string constant CALL_ERROR_MESSAGE = \"actor call failed\";\n\n    uint64 constant CALL_ACTOR_PRECOMPILE_ADDR = 0x0e;\n    uint64 constant MAX_RAW_RESPONSE_SIZE = 0x300;\n    uint64 constant READ_ONLY_FLAG = 0x00000001; // https://github.com/filecoin-project/ref-fvm/blob/master/shared/src/sys/mod.rs#L60\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    function call(\n        uint method_num,\n        bytes memory actor_address,\n        bytes memory raw_request,\n        uint64 codec,\n        uint256 amount\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(\n            abi.encode(uint64(method_num), amount, DEFAULT_FLAG, codec, raw_request, actor_address)\n        );\n        require(success == true, CALL_ERROR_MESSAGE);\n\n        return data;\n    }\n\n    function callByID(\n        uint64 actor_id,\n        uint method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 amount\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(\n            abi.encode(uint64(method_num), amount, DEFAULT_FLAG, codec, raw_request, actor_id)\n        );\n        require(success == true, CALL_ERROR_MESSAGE);\n\n        return data;\n    }\n\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(raw_response, (int256, uint64, bytes));\n\n        require(return_codec == Misc.NONE_CODEC || return_codec == Misc.CBOR_CODEC, \"response codec not supported\");\n        require(exit == 0, getErrorCodeMsg(exit));\n\n        return return_value;\n    }\n\n    function getErrorCodeMsg(int256 exit_code) internal pure returns (string memory) {\n        if (exit_code < 0) {\n            return string.concat(\"actor error code -\", Strings.toString(uint256(exit_code)));\n        }\n        return string.concat(\"actor error code -\", Strings.toString(uint256(exit_code)));\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n// \tMajUnsignedInt = 0\n// \tMajSignedInt   = 1\n// \tMajByteString  = 2\n// \tMajTextString  = 3\n// \tMajArray       = 4\n// \tMajMap         = 5\n// \tMajTag         = 6\n// \tMajOther       = 7\n\nuint8 constant MajUnsignedInt = 0;\nuint8 constant MajSignedInt = 1;\nuint8 constant MajByteString = 2;\nuint8 constant MajTextString = 3;\nuint8 constant MajArray = 4;\nuint8 constant MajMap = 5;\nuint8 constant MajTag = 6;\nuint8 constant MajOther = 7;\n\nuint8 constant TagTypeBigNum = 2;\nuint8 constant TagTypeNegativeBigNum = 3;\n\nuint8 constant True_Type = 21;\nuint8 constant False_Type = 20;\n\nlibrary CBORDecoder {\n    function isNullNext(bytes memory cborParams, uint byteIdx) internal pure returns (bool) {\n        return cborParams[byteIdx] == hex\"f6\";\n    }\n\n    function readBool(bytes memory cborParams, uint byteIdx) internal pure returns (bool, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajOther);\n        assert(value == True_Type || value == False_Type);\n\n        return (value != False_Type, byteIdx);\n    }\n\n    function readFixedArray(bytes memory cborParams, uint byteIdx) internal pure returns (uint, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajArray);\n\n        return (len, byteIdx);\n    }\n\n    function readString(bytes memory cborParams, uint byteIdx) internal pure returns (string memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTextString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (string(slice), byteIdx + len);\n    }\n\n    function readBytes(bytes memory cborParams, uint byteIdx) internal pure returns (bytes memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajByteString);\n\n        if (maj == MajTag) {\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n        }\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (slice, byteIdx + len);\n    }\n\n    function readBytes32(bytes memory cborParams, uint byteIdx) internal pure returns (bytes32, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajByteString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(32);\n        uint slice_index = 32 - len;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (bytes32(slice), byteIdx + len);\n    }\n\n    function readUInt256(bytes memory cborParams, uint byteIdx) internal pure returns (uint256, uint) {\n        uint8 maj;\n        uint256 value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajUnsignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (value, byteIdx + len);\n        }\n\n        return (value, byteIdx);\n    }\n\n    function readInt256(bytes memory cborParams, uint byteIdx) internal pure returns (int256, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajSignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeNegativeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (int256(value), byteIdx + len);\n        }\n\n        return (int256(value), byteIdx);\n    }\n\n    function readUInt64(bytes memory cborParams, uint byteIdx) internal pure returns (uint64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint64(value), byteIdx);\n    }\n\n    function readUInt32(bytes memory cborParams, uint byteIdx) internal pure returns (uint32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint32(value), byteIdx);\n    }\n\n    function readUInt16(bytes memory cborParams, uint byteIdx) internal pure returns (uint16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint16(value), byteIdx);\n    }\n\n    function readUInt8(bytes memory cborParams, uint byteIdx) internal pure returns (uint8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint8(value), byteIdx);\n    }\n\n    function readInt64(bytes memory cborParams, uint byteIdx) internal pure returns (int64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int64(uint64(value)), byteIdx);\n    }\n\n    function readInt32(bytes memory cborParams, uint byteIdx) internal pure returns (int32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int32(uint32(value)), byteIdx);\n    }\n\n    function readInt16(bytes memory cborParams, uint byteIdx) internal pure returns (int16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int16(uint16(value)), byteIdx);\n    }\n\n    function readInt8(bytes memory cborParams, uint byteIdx) internal pure returns (int8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int8(uint8(value)), byteIdx);\n    }\n\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\n        require(bs.length >= start + 1, \"slicing out of range\");\n        uint8 x;\n        assembly {\n            x := mload(add(bs, add(0x01, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\n        require(bs.length >= start + 2, \"slicing out of range\");\n        uint16 x;\n        assembly {\n            x := mload(add(bs, add(0x02, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\n        require(bs.length >= start + 4, \"slicing out of range\");\n        uint32 x;\n        assembly {\n            x := mload(add(bs, add(0x04, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\n        require(bs.length >= start + 8, \"slicing out of range\");\n        uint64 x;\n        assembly {\n            x := mload(add(bs, add(0x08, start)))\n        }\n        return x;\n    }\n\n    // Parse cbor header for major type and extra info.\n    // Also return the byte index after moving past header bytes, and the number of bytes consumed\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\n        uint8 first = sliceUInt8(cbor, byteIndex);\n        byteIndex += 1;\n        uint8 maj = (first & 0xe0) >> 5;\n        uint8 low = first & 0x1f;\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\n        assert(low < 28);\n\n        // extra is lower bits\n        if (low < 24) {\n            return (maj, low, byteIndex);\n        }\n\n        // extra in next byte\n        if (low == 24) {\n            uint8 next = sliceUInt8(cbor, byteIndex);\n            byteIndex += 1;\n            assert(next >= 24); // otherwise this is invalid cbor\n            return (maj, next, byteIndex);\n        }\n\n        // extra in next 2 bytes\n        if (low == 25) {\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\n            byteIndex += 2;\n            return (maj, extra16, byteIndex);\n        }\n\n        // extra in next 4 bytes\n        if (low == 26) {\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\n            byteIndex += 4;\n            return (maj, extra32, byteIndex);\n        }\n\n        // extra in next 8 bytes\n        assert(low == 27);\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\n        byteIndex += 8;\n        return (maj, extra64, byteIndex);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Misc.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nlibrary Misc {\n    uint64 constant CBOR_CODEC = 0x71;\n    uint64 constant NONE_CODEC = 0x00;\n\n    function toUint256(bytes32 _bytes) internal pure returns (uint256 value) {\n        return uint256(_bytes);\n    }\n\n    function toInt256(bytes32 _bytes) internal pure returns (int256 value) {\n        return int256(uint256(_bytes));\n    }\n\n    function toUint256(bytes memory _bytes, uint offset) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(_bytes, offset))\n        }\n    }\n\n    function toInt256(bytes memory _bytes, uint offset) internal pure returns (int256 value) {\n        return int256(toUint256(_bytes, offset));\n    }\n\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function toBytes(int256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function copy(uint src, uint dest, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        if (len == 0) return;\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/basic-solidity-examples/SimpleCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n\nerror SimpleCoin__NotEnoughBalance();\n\ncontract SimpleCoin {\n        mapping (address => uint) balances;\n        uint256 private i_tokensToBeMinted;\n\n\n        constructor(uint256 tokensToBeMinted) {\n                balances[tx.origin] = tokensToBeMinted;\n                i_tokensToBeMinted= tokensToBeMinted;\n        }\n\n        function sendCoin(address receiver, uint amount) public returns(bool sufficient) {\n                if (balances[msg.sender] < amount) {\n                        // return false;\n                revert SimpleCoin__NotEnoughBalance();\n                }\n\n                balances[msg.sender] -= amount;\n                balances[receiver] += amount;\n                return true;\n        }\n\n        function getBalanceInEth(address addr) public view returns(uint){\n                return getBalance(addr) * 2;\n        }\n\n        function getBalance(address addr) public view returns(uint) {\n                return balances[addr];\n        }\n\n        function getMintedTokenBalance() public view returns(uint256){\n                return i_tokensToBeMinted;\n        }\n\n\n}"
    },
    "contracts/escrow/Escrow.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./IEscrow.sol\";\nimport \"@zondax/filecoin-solidity/contracts/v0.8/SendAPI.sol\";\nimport {MinerAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/MinerAPI.sol\";\nimport {MinerTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/MinerTypes.sol\";\n\ncontract Escrow is IEscrow {\n    address public lender;\n    address public borrower;\n    bytes public minerActor;\n    uint256 public rateAmount;\n    uint256 public end;\n    bool public started;\n    bool public canTerminate;\n    uint256 public lastWithdraw;\n    uint256 public withdrawInterval;\n\n    constructor(\n        address _lender,\n        address _borrower,\n        bytes memory _minerActor,\n        uint256 _rateAmount,\n        uint256 _end\n    ) {\n        lender = _lender;\n        borrower = _borrower;\n        minerActor = _minerActor;\n        rateAmount = _rateAmount;\n        end = _end;\n    }\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function startLoan() external {\n        require(!started);\n        // set this contract as the new Owner of the Miner Actor\n        MinerAPI.changeOwnerAddress(minerActor, abi.encodePacked(address(this)));\n        // TODO set beneficiary\n        // check owner change\n        // check new owner is Escrow\n        started = true;\n    }\n\n    function transferToMinerActor(uint256 amount) external {\n        require(\n            msg.sender == borrower /* || msg.sender == lender */\n        );\n        require(amount <= address(this).balance);\n        SendAPI.send(minerActor, amount);\n    }\n\n    // valutare se chiamarla noi o il lender\n    function transferFromMinerActor(MinerTypes.WithdrawBalanceParams memory params)\n        external\n        returns (MinerTypes.WithdrawBalanceReturn memory)\n    {\n        require(msg.sender == borrower || msg.sender == lender);\n        return MinerAPI.withdrawBalance(minerActor, params);\n    }\n\n    function nextWithdraw() public view returns (uint256) {\n        return lastWithdraw == 0 ? 0 : (lastWithdraw + withdrawInterval);\n    }\n\n    function repay() external {\n        require(block.timestamp >= nextWithdraw(), \"Too early\");\n        lastWithdraw = block.timestamp;\n        if (address(this).balance >= rateAmount) {\n            //TODO transfer $fil to lender\n            emit PaidRate(block.timestamp, rateAmount);\n        } else {\n            canTerminate = true;\n            emit FailedPaidRate(block.timestamp);\n        }\n    }\n\n    function withdrawBeforLoanStarts() external {\n        require(msg.sender == lender);\n        require(!started);\n        //TODO transfer $fil to lender\n        emit ClosedLoan(block.timestamp, address(this).balance);\n        //TODO selfdescruct\n    }\n\n    function closeLoan() external {\n        require(canTerminate);\n\n        //TODO add all the logic to get back the collateral from Miner Actor\n\n        // change the owner wallet setting the borrower as the new owner\n        MinerAPI.changeOwnerAddress(minerActor, abi.encodePacked(borrower));\n        emit ClosedLoan(block.timestamp, address(this).balance);\n        //TODO selfdescruct\n    }\n\n    function manageCollateral(uint256 amount) external {\n        //TODO\n    }\n}\n"
    },
    "contracts/escrow/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ncontract IEscrow {\n    event PaidRate(uint256 time, uint256 amount);\n    event FailedPaidRate(uint256 time);\n    event CollateralWithdrawn(uint256 amount);\n    event CollateralAdded(uint256 amount);\n    event ClosedLoan(uint256 time, uint256 amount);\n    event Received(address, uint256);\n}\n"
    },
    "contracts/escrow/ILenderManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ncontract ILenderManager {\n    event LenderPosition(\n        address lender,\n        uint256 amount,\n        uint256 key,\n        uint256 endTimestamp,\n        uint256 interestRate\n    );\n\n    event BorrowOrder(\n        address escrow,\n        uint256 loanAmount,\n        uint256 lenderAmountAvailable,\n        uint256 startBlock,\n        uint256 amountToPay,\n        uint256 key,\n        bytes minerActor\n    );\n\n    event CheckReputation(address borrower);\n\n    struct BorrowerOrders {\n        address borrower;\n        uint256 loanAmount;\n        uint256 startBlock; // when the loan starts\n        uint256 amountToPayEveryBlock;\n        address escrow;\n    }\n\n    struct LendingPosition {\n        address lender;\n        uint256 availableAmount;\n        uint256 endTimestamp;\n        uint256 interestRate;\n    }\n}\n"
    },
    "contracts/escrow/LenderManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/*\n * First draft of the LendingManager contract. See TODO and optimize code\n */\n\n// import \"hardhat/console.sol\";\nimport \"./ILenderManager.sol\";\nimport \"./Escrow.sol\";\nimport {MinerAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/MinerAPI.sol\";\nimport {MinerTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/MinerTypes.sol\";\nimport {Actor} from \"@zondax/filecoin-solidity/contracts/v0.8/utils/Actor.sol\";\nimport {Misc} from \"@zondax/filecoin-solidity/contracts/v0.8/utils/Misc.sol\";\nimport \"@zondax/filecoin-solidity/contracts/v0.8/SendAPI.sol\";\n\n// import \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract LenderManager is ILenderManager {\n    mapping(uint256 => LendingPosition) positions;\n    mapping(uint256 => BorrowerOrders[]) ordersForLending;\n    mapping(uint256 => address[]) escrowContracts;\n\n    constructor() {}\n\n    function createLendingPosition(uint256 duration, uint256 loanInterestRate) public payable {\n        require(msg.value > 0, \"send some FIL to create a lending position\");\n        require(duration > block.timestamp, \"duration must be greater than current timestamp\");\n        uint256 key = uint256(\n            keccak256(abi.encodePacked(block.timestamp, msg.sender, blockhash(block.number - 1)))\n        );\n        positions[key] = LendingPosition(msg.sender, msg.value, duration, loanInterestRate);\n        emit LenderPosition(msg.sender, msg.value, key, duration, loanInterestRate);\n    }\n\n    function createBorrow(\n        uint256 loanKey,\n        uint256 amount,\n        bytes memory minerActorAddress\n    ) public {\n        //TODO check on loanKey\n        //TODO require(checkIsOwner(msg.sender, minerActorAddress));\n        // require(checkReputation(minerActorAddress));\n        require(\n            amount <= positions[loanKey].availableAmount &&\n                block.timestamp < positions[loanKey].endTimestamp,\n            \"Lending position not available\"\n        );\n        // (CREATE2) create Escrow. change owner and amount are placeholders. change them with Constructor params\n        address escrow = address(\n            new Escrow{salt: bytes32(abi.encodePacked(uint40(block.timestamp)))}(\n                positions[loanKey].lender,\n                msg.sender,\n                minerActorAddress,\n                amount,\n                positions[loanKey].endTimestamp\n            )\n        );\n        escrowContracts[loanKey].push(payable(escrow));\n        //send FIL to miner actor\n        SendAPI.send(abi.encodePacked(escrow), amount);\n        // update LendingPosition\n        positions[loanKey].availableAmount -= amount;\n        // update BorrowerOrders\n        ordersForLending[loanKey].push(\n            BorrowerOrders(\n                msg.sender,\n                amount,\n                block.timestamp,\n                calculateInterest(), //TODO\n                escrow\n            )\n        );\n        emit BorrowOrder(\n            escrow,\n            amount,\n            positions[loanKey].availableAmount,\n            block.timestamp,\n            calculateInterest(),\n            loanKey,\n            minerActorAddress\n        );\n    }\n\n    function checkIsOwner(address borrower, bytes memory minerActorAddress) public returns (bool) {\n        // TODO convert msg.sender to Filecoin address form or viceversa in order to compare them\n        // MinerTypes.GetOwnerReturn memory getOwnerReturnValue = MinerAPI.getOwner(minerActorID);\n        // return msg.sender == getOwnerReturnValue.owner\n        return true;\n    }\n\n    // function checkReputation(bytes memory minerActor ) public\n    function checkReputation() public {\n        // requestId => borrower\n        emit CheckReputation(msg.sender);\n    }\n\n    // function receiveReputationScore(uint requestId, bytes memory response) external onlyOracle {\n\n    // }\n\n    //TODO\n    function calculateInterest() internal view returns (uint256 amount) {}\n}\n"
    },
    "contracts/filecoin-api-examples/DealRewarder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport { MarketAPI } from \"../lib/filecoin-solidity/contracts/v0.8/MarketAPI.sol\";\nimport { CommonTypes } from \"../lib/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\";\nimport { MarketTypes } from \"../lib/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\";\nimport { Actor, HyperActor } from \"../lib/filecoin-solidity/contracts/v0.8/utils/Actor.sol\";\nimport { Misc } from \"../lib/filecoin-solidity/contracts/v0.8/utils/Misc.sol\";\n\n/* \nContract Usage\n    Step   |   Who   |    What is happening  |   Why \n    ------------------------------------------------\n    Deploy | contract owner   | contract owner deploys address is owner who can call addCID  | create contract setting up rules to follow\n    AddCID | data pinners     | set up cids that the contract will incentivize in deals      | add request for a deal in the filecoin network, \"store data\" function\n    Fund   | contract funders |  add FIL to the contract to later by paid out by deal        | ensure the deal actually gets stored by providing funds for bounty hunter and (indirect) storage provider\n    Claim  | bounty hunter    | claim the incentive to complete the cycle                    | pay back the bounty hunter for doing work for the contract\n\n*/\ncontract DealRewarder {\n    mapping(bytes => bool) public cidSet;\n    mapping(bytes => uint) public cidSizes;\n    mapping(bytes => mapping(uint64 => bool)) public cidProviders;\n\n    address public owner;\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n    uint64 constant METHOD_SEND = 0;\n    \n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function fund(uint64 unused) public payable {}\n\n    function addCID(bytes calldata cidraw, uint size) public {\n       require(msg.sender == owner);\n       cidSet[cidraw] = true;\n       cidSizes[cidraw] = size;\n    }\n\n    function policyOK(bytes memory cidraw, uint64 provider) internal view returns (bool) {\n        bool alreadyStoring = cidProviders[cidraw][provider];\n        return !alreadyStoring;\n    }\n\n    function authorizeData(bytes memory cidraw, uint64 provider, uint size) public {\n        require(cidSet[cidraw], \"cid must be added before authorizing\");\n        require(cidSizes[cidraw] == size, \"data size must match expected\");\n        require(policyOK(cidraw, provider), \"deal failed policy check: has provider already claimed this cid?\");\n\n        cidProviders[cidraw][provider] = true;\n    }\n\n    function claim_bounty(uint64 deal_id) public {\n        MarketTypes.GetDealDataCommitmentReturn memory commitmentRet = MarketAPI.getDealDataCommitment(MarketTypes.GetDealDataCommitmentParams({id: deal_id}));\n        MarketTypes.GetDealProviderReturn memory providerRet = MarketAPI.getDealProvider(MarketTypes.GetDealProviderParams({id: deal_id}));\n\n        authorizeData(commitmentRet.data, providerRet.provider, commitmentRet.size);\n\n        // get dealer (bounty hunter client)\n        MarketTypes.GetDealClientReturn memory clientRet = MarketAPI.getDealClient(MarketTypes.GetDealClientParams({id: deal_id}));\n\n        // send reward to client \n        send(clientRet.client);\n    }\n\n    function call_actor_id(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, uint64 id) public returns (bool, int256, uint64, bytes memory) {\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(abi.encode(method, value, flags, codec, params, id));\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\n        return (success, exit, return_codec, return_value);\n    }\n\n    // send 1 FIL to the filecoin actor at actor_id\n    function send(uint64 actorID) internal {\n        bytes memory emptyParams = \"\";\n        delete emptyParams;\n\n        uint oneFIL = 1000000000000000000;\n        HyperActor.call_actor_id(METHOD_SEND, oneFIL, DEFAULT_FLAG, Misc.NONE_CODEC, emptyParams, actorID);\n\n    }\n\n}\n\n"
    },
    "contracts/filecoin-api-examples/FilecoinMarketConsumer.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {MarketAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol\";\nimport {MarketTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\";\n\ncontract FilecoinMarketConsumer {\n    string public dealLabel;\n    uint64 public dealClientActorId;\n    uint64 public dealProviderActorId;\n    bool public isDealActivated;\n    MarketTypes.GetDealDataCommitmentReturn public dealCommitment;\n    MarketTypes.GetDealTermReturn public dealTerm;\n    MarketTypes.GetDealEpochPriceReturn public dealPricePerEpoch;\n    MarketTypes.GetDealClientCollateralReturn public clientCollateral; \n    MarketTypes.GetDealProviderCollateralReturn public providerCollateral;\n    MarketTypes.GetDealActivationReturn public activationStatus;\n\n    function storeAll(uint64 dealId) public {\n        storeDealLabel(dealId);\n        storeDealClient(dealId);\n        storeDealClientProvider(dealId);\n        storeDealCommitment(dealId);\n        storeDealTerm(dealId);\n        storeDealTotalPrice(dealId);\n        storeClientCollateral(dealId);\n        storeProviderCollateral(dealId);\n        storeDealVerificaton(dealId);\n        storeDealActivationStatus(dealId);\n    } \n\n    function storeDealLabel(uint64 dealId) public  {\n        dealLabel = MarketAPI.getDealLabel(dealId).label;\n    }\n\n    function storeDealClient(uint64 dealId) public {\n        dealClientActorId = MarketAPI.getDealClient(dealId).client;\n    }\n\n    function storeDealClientProvider(uint64 dealId) public {\n        dealProviderActorId = MarketAPI.getDealProvider(dealId).provider;\n    }\n\n    function storeDealCommitment(uint64 dealId) public {\n        dealCommitment = MarketAPI.getDealDataCommitment(dealId);\n    }\n\n    function storeDealTerm(uint64 dealId) public {\n        dealTerm = MarketAPI.getDealTerm(dealId);\n    }\n\n    function storeDealTotalPrice(uint64 dealId) public {\n       dealPricePerEpoch = MarketAPI.getDealTotalPrice(dealId);\n    }\n\n    function storeClientCollateral(uint64 dealId) public {\n        clientCollateral = MarketAPI.getDealClientCollateral(dealId);\n    }\n    \n    function storeProviderCollateral(uint64 dealId) public {\n        providerCollateral = MarketAPI.getDealProviderCollateral(dealId);\n    }\n\n    function storeDealVerificaton(uint64 dealId) public {\n        isDealActivated = MarketAPI.getDealVerified(dealId).verified;\n    }\n\n    function storeDealActivationStatus(uint64 dealId) public {\n        activationStatus = MarketAPI.getDealActivation(dealId);\n    }\n}"
    },
    "contracts/lib/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "contracts/lib/buffer/test/TestBuffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity >=0.8.4;\n\nimport \"./../contracts/Buffer.sol\";\n\ncontract TestBuffer {\n    using Buffer for Buffer.buffer;\n\n    function checkBufferInitOverflow() public pure {\n        Buffer.buffer memory buf;\n        buf.init(256);\n        buf.init(2**256-1);\n    }\n\n    function testBufferAppend() public pure {\n        Buffer.buffer memory buf;\n        buf.init(256);\n        buf.append(\"Hello\");\n        buf.append(\", \");\n        buf.append(\"world!\");\n        require(\n          keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"Hello, world!\")),\n          \"Unexpected buffer contents.\"\n        );\n    }\n\n    function testBufferAppendUint8() public pure {\n        Buffer.buffer memory buf;\n        Buffer.init(buf, 256);\n        buf.append(\"Hello,\");\n        buf.appendUint8(0x20);\n        buf.append(\"world!\");\n        require(\n          keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"Hello, world!\")),\n          \"Unexpected buffer contents.\"\n        );\n    }\n\n    function testBufferResizeAppendUint8() public pure {\n        Buffer.buffer memory buf;\n        Buffer.init(buf, 32);\n        buf.append(\"01234567890123456789012345678901\");\n        buf.appendUint8(0x20);\n        require(buf.capacity == 96, \"Expected buffer capacity to be 96\");\n        require(buf.buf.length == 33, \"Expected buffer length to be 33\");\n        require(\n          keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"01234567890123456789012345678901 \")),\n          \"Unexpected buffer contents.\"\n        );\n    }\n\n    function testBufferResizeAppendBytes() public pure {\n      Buffer.buffer memory buf;\n      Buffer.init(buf, 32);\n      buf.append(\"01234567890123456789012345678901\");\n      buf.append(\"23\");\n      require(buf.capacity == 96, \"Expected buffer capacity to be 96\");\n      require(buf.buf.length == 34, \"Expected buffer length to be 33\");\n      require(\n        keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"0123456789012345678901234567890123\")),\n        \"Unexpected buffer contents.\"\n      );\n    }\n\n    function testBufferResizeAppendManyBytes() public pure {\n      Buffer.buffer memory buf;\n      Buffer.init(buf, 32);\n      buf.append(\"01234567890123456789012345678901\");\n      buf.append(\"0123456789012345678901234567890101234567890123456789012345678901\");\n      require(buf.capacity == 192, \"Expected buffer capacity to be 192\");\n      require(buf.buf.length == 96, \"Expected buffer length to be 96\");\n      require(\n        keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"012345678901234567890123456789010123456789012345678901234567890101234567890123456789012345678901\")),\n        \"Unexpected buffer contents.\"\n      );\n    }\n\n    function testBufferZeroSized() public pure {\n      Buffer.buffer memory buf;\n      Buffer.init(buf, 0);\n      buf.append(\"first\");\n      require(buf.capacity == 32, \"Expected buffer capacity to be 32\");\n      require(buf.buf.length == 5, \"Expected buffer length to be 5\");\n      require(\n        keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"first\")),\n        \"Unexpected buffer contents.\"\n      );\n    }\n\n    function testBufferAppendInt() public pure {\n      Buffer.buffer memory buf;\n      Buffer.init(buf, 256);\n      buf.append(\"Hello\");\n      buf.appendInt(0x2c20, 2);\n      buf.append(\"world!\");\n      require(\n        keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"Hello, world!\")),\n        \"Unexpected buffer contents.\"\n      );\n    }\n\n    function testBufferResizeAppendInt() public pure {\n      Buffer.buffer memory buf;\n      Buffer.init(buf, 32);\n      buf.append(\"01234567890123456789012345678901\");\n      buf.appendInt(0x2020, 2);\n      require(buf.capacity == 96, \"Expected buffer capacity to be 96\");\n      require(buf.buf.length ==  34, \"Expected buffer length to be 34\");\n      require(\n        keccak256(abi.encodePacked(string(buf.buf))) == keccak256(abi.encodePacked(\"01234567890123456789012345678901  \")),\n        \"Unexpected buffer contents.\"\n      );\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/AccountAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/AccountTypes.sol\";\nimport \"./cbor/AccountCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the Account actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary AccountAPI {\n    using AuthenticateMessageCBOR for AccountTypes.AuthenticateMessageParams;\n    using UniversalReceiverHookCBOR for AccountTypes.UniversalReceiverParams;\n    using BytesCBOR for bytes;\n\n    /// @notice FIXME\n    function authenticateMessage(bytes memory target, AccountTypes.AuthenticateMessageParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(AccountTypes.AuthenticateMessageMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice FIXME\n    function universalReceiverHook(bytes memory target, AccountTypes.UniversalReceiverParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(AccountTypes.UniversalReceiverHookMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/AccountCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {AccountTypes} from \"../types/AccountTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary AuthenticateMessageCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(AccountTypes.AuthenticateMessageParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.signature);\n        buf.writeBytes(params.message);\n\n        return buf.data();\n    }\n\n    function deserialize(AccountTypes.AuthenticateMessageParams memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.signature, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.message, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary UniversalReceiverHookCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(AccountTypes.UniversalReceiverParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.type_);\n        buf.writeBytes(params.payload);\n\n        return buf.data();\n    }\n}\n\nlibrary BytesCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeBytes(bytes memory data) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(data);\n\n        return buf.data();\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nstruct BigInt {\n    bytes val;\n    bool neg;\n}\n\nlibrary BigIntCBOR {\n    function serializeBigNum(BigInt memory num) internal pure returns (bytes memory) {\n        // TODO improve gas efficiency by using assembly code\n        bytes memory raw = new bytes(num.val.length + 1);\n\n        if (num.neg) {\n            raw[0] = 0x01;\n        }\n\n        uint index = 1;\n        for (uint i = 0; i < num.val.length; i++) {\n            raw[index] = num.val[i];\n            index++;\n        }\n\n        return raw;\n    }\n\n    function deserializeBigNum(bytes memory raw) internal pure returns (BigInt memory) {\n        // TODO improve gas efficiency by using assembly code\n\n        // Is an empty byte a valid BigInt ? We should have the sign byte at least\n        if (raw.length == 0) {\n            return BigInt(hex\"00\", false);\n        }\n\n        bytes memory val = new bytes(raw.length - 1);\n        bool neg = false;\n\n        if (raw[0] == 0x01) {\n            neg = true;\n        }\n\n        for (uint i = 1; i < raw.length; i++) {\n            val[i - 1] = raw[i];\n        }\n\n        return BigInt(val, neg);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/DataCapCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {DataCapTypes} from \"../types/DataCapTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\nlibrary BytesCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function serializeNull() internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeNull();\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n\n    function deserializeString(bytes memory ret) internal pure returns (string memory) {\n        string memory response;\n        uint byteIdx = 0;\n\n        (response, byteIdx) = ret.readString(byteIdx);\n\n        return response;\n    }\n\n    function deserializeBigNum(bytes memory ret) internal pure returns (BigInt memory) {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        if (ret.length > 0) {\n            (tmp, byteIdx) = ret.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                return tmp.deserializeBigNum();\n            }\n        }\n\n        return BigInt(new bytes(0), false);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary GetAllowanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(DataCapTypes.GetAllowanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.owner);\n        buf.writeBytes(params.operator);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary TransferCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(DataCapTypes.TransferParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(3);\n        buf.writeBytes(params.to);\n        buf.writeBytes(params.amount.serializeBigNum());\n        buf.writeBytes(params.operator_data);\n\n        return buf.data();\n    }\n\n    function deserialize(DataCapTypes.TransferReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.from_balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.to_balance = tmp.deserializeBigNum();\n\n        (ret.recipient_data, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary TransferFromCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(DataCapTypes.TransferFromParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(4);\n        buf.writeBytes(params.from);\n        buf.writeBytes(params.to);\n        buf.writeBytes(params.amount.serializeBigNum());\n        buf.writeBytes(params.operator_data);\n\n        return buf.data();\n    }\n\n    function deserialize(DataCapTypes.TransferFromReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 4);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.from_balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.to_balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.allowance = tmp.deserializeBigNum();\n\n        (ret.recipient_data, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary IncreaseAllowanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(DataCapTypes.IncreaseAllowanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.operator);\n        buf.writeBytes(params.increase.serializeBigNum());\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary DecreaseAllowanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(DataCapTypes.DecreaseAllowanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.operator);\n        buf.writeBytes(params.decrease.serializeBigNum());\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary RevokeAllowanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(DataCapTypes.RevokeAllowanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.operator);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary BurnCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(DataCapTypes.BurnParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.amount.serializeBigNum());\n\n        return buf.data();\n    }\n\n    function deserialize(DataCapTypes.BurnReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigNum();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary BurnFromCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(DataCapTypes.BurnFromParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.owner);\n        buf.writeBytes(params.amount.serializeBigNum());\n\n        return buf.data();\n    }\n\n    function deserialize(DataCapTypes.BurnFromReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.allowance = tmp.deserializeBigNum();\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/FilecoinCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary FilecoinCbor {\n    using Buffer for Buffer.buffer;\n    using CBOR for CBOR.CBORBuffer;\n\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant TAG_TYPE_CID_CODE = 42;\n    uint8 private constant PAYLOAD_LEN_8_BITS = 24;\n\n    function writeCid(CBOR.CBORBuffer memory buf, bytes memory value) internal pure {\n        buf.buf.appendUint8(uint8(((MAJOR_TYPE_TAG << 5) | PAYLOAD_LEN_8_BITS)));\n        buf.buf.appendUint8(TAG_TYPE_CID_CODE);\n        buf.writeBytes(value);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/InitCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {InitTypes} from \"../types/InitTypes.sol\";\nimport \"./FilecoinCbor.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ExecCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using FilecoinCbor for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(InitTypes.ExecParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeCid(params.code_cid);\n        buf.writeBytes(params.constructor_params);\n\n        return buf.data();\n    }\n\n    function deserialize(InitTypes.ExecReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.id_address, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.robust_address, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary Exec4CBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using FilecoinCbor for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(InitTypes.Exec4Params memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(3);\n        buf.writeCid(params.code_cid);\n        buf.writeBytes(params.constructor_params);\n        buf.writeBytes(params.subaddress);\n\n        return buf.data();\n    }\n\n    function deserialize(InitTypes.Exec4Return memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.id_address, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.robust_address, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../../../../solidity-cborutils/contracts/CBOR.sol\";\n\nimport {MarketTypes} from \"../types/MarketTypes.sol\";\nimport \"./BigIntCbor.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary WithdrawBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.provider_or_client);\n        buf.writeBytes(params.tokenAmount.serializeBigNum());\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.amount_withdrawn = tmp.deserializeBigNum();\n    }\n}\n\nlibrary AddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n}\n\nlibrary GetBalanceCBOR {\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.locked = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealDataCommitmentCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealDataCommitmentParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealDataCommitmentReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n\n        if (len > 0) {\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n    }\n}\n\nlibrary GetDealClientCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealClientParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealClientReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.client, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealProviderCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealProviderParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealProviderReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.provider, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealLabelCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealLabelParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealLabelReturn memory ret, bytes memory rawResp) internal pure {\n        string memory label;\n        uint byteIdx = 0;\n\n        (label, byteIdx) = rawResp.readString(byteIdx);\n\n        ret.label = label;\n    }\n}\n\nlibrary GetDealTermCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealTermParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealTermReturn memory ret, bytes memory rawResp) internal pure {\n        int64 start;\n        int64 end;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (start, byteIdx) = rawResp.readInt64(byteIdx);\n        (end, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.start = start;\n        ret.end = end;\n    }\n}\n\nlibrary GetDealEpochPriceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealEpochPriceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealEpochPriceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.price_per_epoch = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealClientCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealClientCollateralParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealClientCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealProviderCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealProviderCollateralParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealProviderCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealVerifiedCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealVerifiedParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealVerifiedReturn memory ret, bytes memory rawResp) internal pure {\n        bool verified;\n        uint byteIdx = 0;\n\n        (verified, byteIdx) = rawResp.readBool(byteIdx);\n\n        ret.verified = verified;\n    }\n}\n\nlibrary GetDealActivationCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealActivationParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealActivationReturn memory ret, bytes memory rawResp) internal pure {\n        int64 activated;\n        int64 terminated;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (activated, byteIdx) = rawResp.readInt64(byteIdx);\n        (terminated, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.activated = activated;\n        ret.terminated = terminated;\n    }\n}\n\nlibrary PublishStorageDealsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.deals.length));\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            buf.startFixedArray(11);\n\n            buf.writeBytes(params.deals[i].proposal.piece_cid);\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\n            buf.writeBool(params.deals[i].proposal.verified_deal);\n            buf.writeBytes(params.deals[i].proposal.client);\n            buf.writeBytes(params.deals[i].proposal.provider);\n            buf.writeString(params.deals[i].proposal.label);\n            buf.writeInt64(params.deals[i].proposal.start_epoch);\n            buf.writeInt64(params.deals[i].proposal.end_epoch);\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigNum());\n\n            buf.writeBytes(params.deals[i].client_signature);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.PublishStorageDealsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.ids = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/MinerCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {MinerTypes} from \"../types/MinerTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ChangeBeneficiaryCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MinerTypes.ChangeBeneficiaryParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(3);\n        buf.writeBytes(params.new_beneficiary);\n        buf.writeBytes(params.new_quota.serializeBigNum());\n        buf.writeUInt64(params.new_expiration);\n\n        return buf.data();\n    }\n}\n\nlibrary GetOwnerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetOwnerReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.owner, byteIdx) = rawResp.readBytes(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (ret.proposed, byteIdx) = rawResp.readBytes(byteIdx);\n        }\n    }\n}\n\nlibrary IsControllingAddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.IsControllingAddressReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.is_controlling, byteIdx) = rawResp.readBool(byteIdx);\n    }\n}\n\nlibrary GetSectorSizeCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetSectorSizeReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.sector_size, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetAvailableBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetAvailableBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.available_balance = tmp.deserializeBigNum();\n        } else {\n            ret.available_balance = BigInt(new bytes(0), false);\n        }\n    }\n}\n\nlibrary AddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n}\n\nlibrary GetBeneficiaryCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetBeneficiaryReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.active.beneficiary, byteIdx) = rawResp.readBytes(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.quota = tmp.deserializeBigNum();\n        } else {\n            ret.active.term.quota = BigInt(new bytes(0), false);\n        }\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.active.term.used_quota = tmp.deserializeBigNum();\n        } else {\n            ret.active.term.used_quota = BigInt(new bytes(0), false);\n        }\n\n        (ret.active.term.expiration, byteIdx) = rawResp.readUInt64(byteIdx);\n\n        if (!rawResp.isNullNext(byteIdx)) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 5);\n\n            (ret.proposed.new_beneficiary, byteIdx) = rawResp.readBytes(byteIdx);\n\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                ret.proposed.new_quota = tmp.deserializeBigNum();\n            } else {\n                ret.proposed.new_quota = BigInt(new bytes(0), false);\n            }\n\n            (ret.proposed.new_expiration, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.proposed.approved_by_beneficiary, byteIdx) = rawResp.readBool(byteIdx);\n            (ret.proposed.approved_by_nominee, byteIdx) = rawResp.readBool(byteIdx);\n        }\n    }\n}\n\nlibrary GetVestingFundsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MinerTypes.GetVestingFundsReturn memory ret, bytes memory rawResp) internal pure {\n        int64 epoch;\n        BigInt memory amount;\n        bytes memory tmp;\n\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.vesting_funds = new CommonTypes.VestingFunds[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (epoch, byteIdx) = rawResp.readInt64(byteIdx);\n            (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n\n            amount = tmp.deserializeBigNum();\n            ret.vesting_funds[i] = CommonTypes.VestingFunds(epoch, amount);\n        }\n    }\n}\n\nlibrary ChangeWorkerAddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangeWorkerAddressParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.new_worker);\n        buf.startFixedArray(uint64(params.new_control_addresses.length));\n\n        for (uint64 i = 0; i < params.new_control_addresses.length; i++) {\n            buf.writeBytes(params.new_control_addresses[i]);\n        }\n\n        return buf.data();\n    }\n}\n\nlibrary ChangePeerIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangePeerIDParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.new_id);\n\n        return buf.data();\n    }\n}\n\nlibrary ChangeMultiaddrsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.ChangeMultiaddrsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.new_multi_addrs.length));\n\n        for (uint64 i = 0; i < params.new_multi_addrs.length; i++) {\n            buf.writeBytes(params.new_multi_addrs[i]);\n        }\n\n        return buf.data();\n    }\n}\n\nlibrary GetPeerIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetPeerIDReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        (ret.peer_id, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\nlibrary GetMultiaddrsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MinerTypes.GetMultiaddrsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.multi_addrs = new bytes[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.multi_addrs[i], byteIdx) = rawResp.readBytes(byteIdx);\n        }\n    }\n}\n\nlibrary WithdrawBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MinerTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(params.amount_requested);\n\n        return buf.data();\n    }\n\n    function deserialize(MinerTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.amount_withdrawn, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/MultisigCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {MultisigTypes} from \"../types/MultisigTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\nlibrary BytesCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeBytes(bytes memory data) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(data);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ProposeCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MultisigTypes.ProposeParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(4);\n        buf.writeBytes(params.to);\n        buf.writeBytes(params.value.serializeBigNum());\n        buf.writeUInt64(params.method);\n        buf.writeBytes(params.params);\n\n        return buf.data();\n    }\n\n    function deserialize(MultisigTypes.ProposeReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 4);\n\n        (ret.txn_id, byteIdx) = rawResp.readInt64(byteIdx);\n        (ret.applied, byteIdx) = rawResp.readBool(byteIdx);\n        (ret.code, byteIdx) = rawResp.readUInt32(byteIdx);\n        (ret.ret, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary TxnIDCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MultisigTypes.TxnIDParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeInt64(params.id);\n        buf.writeBytes(params.proposal_hash);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ApproveCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(MultisigTypes.ApproveReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (ret.applied, byteIdx) = rawResp.readBool(byteIdx);\n        (ret.code, byteIdx) = rawResp.readUInt32(byteIdx);\n        (ret.ret, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary AddSignerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MultisigTypes.AddSignerParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.signer);\n        buf.writeBool(params.increase);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary RemoveSignerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MultisigTypes.RemoveSignerParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.signer);\n        buf.writeBool(params.decrease);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary SwapSignerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MultisigTypes.SwapSignerParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.from);\n        buf.writeBytes(params.to);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ChangeNumApprovalsThresholdCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MultisigTypes.ChangeNumApprovalsThresholdParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.writeUInt64(params.new_threshold);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary LockBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MultisigTypes.LockBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(3);\n        buf.writeInt64(params.start_epoch);\n        buf.writeInt64(params.unlock_duration);\n        buf.writeBytes(params.amount.serializeBigNum());\n\n        return buf.data();\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/PowerCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {PowerTypes} from \"../types/PowerTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary CreateMinerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(PowerTypes.CreateMinerParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        uint multiaddrsLen = params.multiaddrs.length;\n\n        buf.startFixedArray(5);\n        buf.writeBytes(params.owner);\n        buf.writeBytes(params.worker);\n        buf.writeInt64(int64(uint64(params.window_post_proof_type)));\n        buf.writeBytes(params.peer);\n        buf.startFixedArray(uint64(multiaddrsLen));\n        for (uint i = 0; i < multiaddrsLen; i++) {\n            buf.writeBytes(params.multiaddrs[i]);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(PowerTypes.CreateMinerReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.id_address, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.robust_address, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary MinerCountCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(PowerTypes.MinerCountReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        // REVIEW: The ouput returned is '00' so it unsigned but the type described in buitin is i64.\n        (ret.miner_count, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary MinerConsensusCountCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function deserialize(PowerTypes.MinerConsensusCountReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.miner_consensus_count, byteIdx) = rawResp.readInt64(byteIdx);\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary NetworkRawPowerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(PowerTypes.NetworkRawPowerReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.raw_byte_power = tmp.deserializeBigNum();\n        } else {\n            ret.raw_byte_power = BigInt(new bytes(0), false);\n        }\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary MinerRawPowerCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(PowerTypes.MinerRawPowerParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.miner);\n\n        return buf.data();\n    }\n\n    function deserialize(PowerTypes.MinerRawPowerReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        if (tmp.length > 0) {\n            ret.raw_byte_power = tmp.deserializeBigNum();\n        } else {\n            ret.raw_byte_power = BigInt(new bytes(0), false);\n        }\n\n        (ret.meets_consensus_minimum, byteIdx) = rawResp.readBool(byteIdx);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/cbor/VerifRegCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {CommonTypes} from \"../types/CommonTypes.sol\";\nimport {VerifRegTypes} from \"../types/VerifRegTypes.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\nimport \"./BigIntCbor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary GetClaimsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(VerifRegTypes.GetClaimsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        uint claimIdsLen = params.claim_ids.length;\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.provider);\n        buf.startFixedArray(uint64(claimIdsLen));\n        for (uint i = 0; i < claimIdsLen; i++) {\n            buf.writeUInt64(params.claim_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(VerifRegTypes.GetClaimsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.batch_info.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.batch_info.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.batch_info.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.batch_info.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.claims = new CommonTypes.Claim[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 8);\n\n            (ret.claims[i].provider, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.claims[i].client, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.claims[i].data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.claims[i].size, byteIdx) = rawResp.readUInt64(byteIdx);\n            (ret.claims[i].term_min, byteIdx) = rawResp.readInt64(byteIdx);\n            (ret.claims[i].term_max, byteIdx) = rawResp.readInt64(byteIdx);\n            (ret.claims[i].term_start, byteIdx) = rawResp.readInt64(byteIdx);\n            (ret.claims[i].sector, byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n    }\n}\n\nlibrary AddVerifierClientCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(VerifRegTypes.AddVerifierClientParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.addr);\n        buf.writeBytes(params.allowance);\n\n        return buf.data();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary RemoveExpiredAllocationsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(VerifRegTypes.RemoveExpiredAllocationsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        uint allocationIdsLen = params.allocation_ids.length;\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.client);\n        buf.startFixedArray(uint64(allocationIdsLen));\n        for (uint i = 0; i < allocationIdsLen; i++) {\n            buf.writeUInt64(params.allocation_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(VerifRegTypes.RemoveExpiredAllocationsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.considered = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.considered[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        bytes memory tmp;\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.datacap_recovered = tmp.deserializeBigNum();\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary ExtendClaimTermsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(VerifRegTypes.ExtendClaimTermsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        uint termsLen = params.terms.length;\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(termsLen));\n        for (uint i = 0; i < termsLen; i++) {\n            buf.startFixedArray(3);\n            buf.writeUInt64(params.terms[i].provider);\n            buf.writeUInt64(params.terms[i].claim_id);\n            buf.writeInt64(params.terms[i].term_max);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(CommonTypes.BatchReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary RemoveExpiredClaimsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(VerifRegTypes.RemoveExpiredClaimsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        uint claimIdsLen = params.claim_ids.length;\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.provider);\n        buf.startFixedArray(uint64(claimIdsLen));\n        for (uint i = 0; i < claimIdsLen; i++) {\n            buf.writeUInt64(params.claim_ids[i]);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(VerifRegTypes.RemoveExpiredClaimsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.considered = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.considered[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n    }\n}\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary UniversalReceiverHookCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(VerifRegTypes.UniversalReceiverParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.type_);\n        buf.writeBytes(params.payload);\n\n        return buf.data();\n    }\n\n    function deserialize(VerifRegTypes.AllocationsResponse memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 3);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.allocation_results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.allocation_results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.allocation_results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.allocation_results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.extension_results.success_count, byteIdx) = rawResp.readUInt32(byteIdx);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.extension_results.fail_codes = new CommonTypes.FailCode[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n            assert(len == 2);\n\n            (ret.extension_results.fail_codes[i].idx, byteIdx) = rawResp.readUInt32(byteIdx);\n            (ret.extension_results.fail_codes[i].code, byteIdx) = rawResp.readUInt32(byteIdx);\n        }\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.new_allocations = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.new_allocations[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/DataCapAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/DataCapTypes.sol\";\nimport \"./cbor/DataCapCbor.sol\";\nimport \"./cbor/BigIntCbor.sol\";\n\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the singleton DataCap actor (address: f0X). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary DataCapAPI {\n    using BytesCBOR for bytes;\n    using GetAllowanceCBOR for DataCapTypes.GetAllowanceParams;\n    using TransferCBOR for DataCapTypes.TransferParams;\n    using TransferCBOR for DataCapTypes.TransferReturn;\n    using TransferFromCBOR for DataCapTypes.TransferFromParams;\n    using TransferFromCBOR for DataCapTypes.TransferFromReturn;\n    using IncreaseAllowanceCBOR for DataCapTypes.IncreaseAllowanceParams;\n    using DecreaseAllowanceCBOR for DataCapTypes.DecreaseAllowanceParams;\n    using RevokeAllowanceCBOR for DataCapTypes.RevokeAllowanceParams;\n    using BurnCBOR for DataCapTypes.BurnParams;\n    using BurnCBOR for DataCapTypes.BurnReturn;\n    using BurnFromCBOR for DataCapTypes.BurnFromParams;\n    using BurnFromCBOR for DataCapTypes.BurnFromReturn;\n\n    function name() internal returns (string memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(DataCapTypes.NameMethodNum, DataCapTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeString();\n    }\n\n    function symbol() internal returns (string memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(DataCapTypes.SymbolMethodNum, DataCapTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeString();\n    }\n\n    function totalSupply() internal returns (BigInt memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(DataCapTypes.TotalSupplyMethodNum, DataCapTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function balance(bytes memory addr) internal returns (BigInt memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.BalanceOfMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function allowance(DataCapTypes.GetAllowanceParams memory params) internal returns (BigInt memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.AllowanceMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function transfer(DataCapTypes.TransferParams memory params) internal returns (DataCapTypes.TransferReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.TransferMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        DataCapTypes.TransferReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function transferFrom(DataCapTypes.TransferFromParams memory params) internal returns (DataCapTypes.TransferFromReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.TransferFromMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        DataCapTypes.TransferFromReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function increaseAllowance(DataCapTypes.IncreaseAllowanceParams memory params) internal returns (BigInt memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            DataCapTypes.IncreaseAllowanceMethodNum,\n            DataCapTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function decreaseAllowance(DataCapTypes.DecreaseAllowanceParams memory params) internal returns (BigInt memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            DataCapTypes.DecreaseAllowanceMethodNum,\n            DataCapTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function revokeAllowance(DataCapTypes.RevokeAllowanceParams memory params) internal returns (BigInt memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.RevokeAllowanceMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        return result.deserializeBigNum();\n    }\n\n    function burn(DataCapTypes.BurnParams memory params) internal returns (DataCapTypes.BurnReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.BurnMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        DataCapTypes.BurnReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function burnFrom(DataCapTypes.BurnFromParams memory params) internal returns (DataCapTypes.BurnFromReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(DataCapTypes.BurnFromMethodNum, DataCapTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        DataCapTypes.BurnFromReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/InitAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/InitTypes.sol\";\nimport \"./cbor/InitCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the singleton Init actor (address: f01). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary InitAPI {\n    using ExecCBOR for InitTypes.ExecParams;\n    using ExecCBOR for InitTypes.ExecReturn;\n    using Exec4CBOR for InitTypes.Exec4Params;\n    using Exec4CBOR for InitTypes.Exec4Return;\n\n    /// @notice FIXME\n    function exec(InitTypes.ExecParams memory params) internal returns (InitTypes.ExecReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(InitTypes.ExecMethodNum, InitTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        InitTypes.ExecReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice FIXME\n    function exec4(InitTypes.Exec4Params memory params) internal returns (InitTypes.Exec4Return memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(InitTypes.Exec4MethodNum, InitTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        InitTypes.Exec4Return memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/MarketAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MarketTypes.sol\";\nimport \"./cbor/MarketCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n\nlibrary MarketAPI {\n    using AddressCBOR for bytes;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentParams;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\n    using GetDealClientCBOR for MarketTypes.GetDealClientParams;\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderParams;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelParams;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\n    using GetDealTermCBOR for MarketTypes.GetDealTermParams;\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceParams;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralParams;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralParams;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedParams;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationParams;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    function getDealDataCommitment(\n        MarketTypes.GetDealDataCommitmentParams memory params\n    ) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory result = HyperActor.call(\n            MarketTypes.GetDealDataCommitmentMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        MarketTypes.GetDealDataCommitmentReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client of a deal proposal.\n    function getDealClient(MarketTypes.GetDealClientParams memory params) internal returns (MarketTypes.GetDealClientReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory result = HyperActor.call(MarketTypes.GetDealClientMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        MarketTypes.GetDealClientReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider of a deal proposal.\n    function getDealProvider(MarketTypes.GetDealProviderParams memory params) internal returns (MarketTypes.GetDealProviderReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory result = HyperActor.call(MarketTypes.GetDealProviderMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        MarketTypes.GetDealProviderReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n    \n}\n\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MarketAPIOld {\n    using AddressCBOR for bytes;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentParams;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\n    using GetDealClientCBOR for MarketTypes.GetDealClientParams;\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderParams;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelParams;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\n    using GetDealTermCBOR for MarketTypes.GetDealTermParams;\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceParams;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralParams;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralParams;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedParams;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationParams;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    function addBalance(bytes memory provider_or_client) internal {\n        bytes memory raw_request = provider_or_client.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MarketTypes.AddBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (MarketTypes.WithdrawBalanceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.WithdrawBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.WithdrawBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(bytes memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    function getDealDataCommitment(\n        MarketTypes.GetDealDataCommitmentParams memory params\n    ) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealDataCommitmentMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealDataCommitmentReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client of a deal proposal.\n    function getDealClient(MarketTypes.GetDealClientParams memory params) internal returns (MarketTypes.GetDealClientReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealClientMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider of a deal proposal.\n    function getDealProvider(MarketTypes.GetDealProviderParams memory params) internal returns (MarketTypes.GetDealProviderReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealProviderMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the label of a deal proposal.\n    function getDealLabel(MarketTypes.GetDealLabelParams memory params) internal returns (MarketTypes.GetDealLabelReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealLabelMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealLabelReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(MarketTypes.GetDealTermParams memory params) internal returns (MarketTypes.GetDealTermReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealTermMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealTermReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(\n        MarketTypes.GetDealEpochPriceParams memory params\n    ) internal returns (MarketTypes.GetDealEpochPriceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealEpochPriceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealEpochPriceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(\n        MarketTypes.GetDealClientCollateralParams memory params\n    ) internal returns (MarketTypes.GetDealClientCollateralReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealClientCollateralMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(\n        MarketTypes.GetDealProviderCollateralParams memory params\n    ) internal returns (MarketTypes.GetDealProviderCollateralReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealProviderCollateralMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function getDealVerified(MarketTypes.GetDealVerifiedParams memory params) internal returns (MarketTypes.GetDealVerifiedReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealVerifiedMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealVerifiedReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(\n        MarketTypes.GetDealActivationParams memory params\n    ) internal returns (MarketTypes.GetDealActivationReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealActivationMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealActivationReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(\n        MarketTypes.PublishStorageDealsParams memory params\n    ) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.PublishStorageDealsMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.PublishStorageDealsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/MinerAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MinerTypes.sol\";\nimport \"./cbor/MinerCbor.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @notice During miner initialization, a miner actor is created on the chain, and this actor gives the miner its ID f0.... The miner actor is in charge of collecting all the payments sent to the miner.\n/// @dev For more info about the miner actor, please refer to https://lotus.filecoin.io/storage-providers/operate/addresses/\n/// @author Zondax AG\nlibrary MinerAPI {\n    using ChangeBeneficiaryCBOR for MinerTypes.ChangeBeneficiaryParams;\n    using GetOwnerCBOR for MinerTypes.GetOwnerReturn;\n    using AddressCBOR for bytes;\n    using IsControllingAddressCBOR for MinerTypes.IsControllingAddressReturn;\n    using GetSectorSizeCBOR for MinerTypes.GetSectorSizeReturn;\n    using GetAvailableBalanceCBOR for MinerTypes.GetAvailableBalanceReturn;\n    using GetVestingFundsCBOR for MinerTypes.GetVestingFundsReturn;\n    using GetBeneficiaryCBOR for MinerTypes.GetBeneficiaryReturn;\n    using ChangeWorkerAddressCBOR for MinerTypes.ChangeWorkerAddressParams;\n    using ChangePeerIDCBOR for MinerTypes.ChangePeerIDParams;\n    using ChangeMultiaddrsCBOR for MinerTypes.ChangeMultiaddrsParams;\n    using GetPeerIDCBOR for MinerTypes.GetPeerIDReturn;\n    using GetMultiaddrsCBOR for MinerTypes.GetMultiaddrsReturn;\n    using WithdrawBalanceCBOR for MinerTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MinerTypes.WithdrawBalanceReturn;\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @param target The miner address (type ID) you want to interact with\n    /// @return the owner address of a Miner\n    function getOwner(bytes memory target) internal returns (MinerTypes.GetOwnerReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetOwnerMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetOwnerReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function changeOwnerAddress(bytes memory target, bytes memory addr) internal {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeOwnerAddressMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param addr The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function isControllingAddress(bytes memory target, bytes memory addr) internal returns (MinerTypes.IsControllingAddressReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MinerTypes.IsControllingAddressMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.IsControllingAddressReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the miner's sector size.\n    /// @param target The miner address (type ID) you want to interact with\n    /// @dev For more information about sector sizes, please refer to https://spec.filecoin.io/systems/filecoin_mining/sector/#section-systems.filecoin_mining.sector\n    function getSectorSize(bytes memory target) internal returns (MinerTypes.GetSectorSizeReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetSectorSizeMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetSectorSizeReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function getAvailableBalance(bytes memory target) internal returns (MinerTypes.GetAvailableBalanceReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetAvailableBalanceMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetAvailableBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function getVestingFunds(bytes memory target) internal returns (MinerTypes.GetVestingFundsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetVestingFundsMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetVestingFundsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function changeBeneficiary(bytes memory target, MinerTypes.ChangeBeneficiaryParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeBeneficiaryMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @param target The miner address (type ID) you want to interact with\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function getBeneficiary(bytes memory target) internal returns (MinerTypes.GetBeneficiaryReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetBeneficiaryMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetBeneficiaryReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changeWorkerAddress(bytes memory target, MinerTypes.ChangeWorkerAddressParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeWorkerAddressMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changePeerId(bytes memory target, MinerTypes.ChangePeerIDParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangePeerIDMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function changeMultiaddresses(bytes memory target, MinerTypes.ChangeMultiaddrsParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.ChangeMultiaddrsMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function repayDebt(bytes memory target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.RepayDebtMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function confirmChangeWorkerAddress(bytes memory target) internal {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.ConfirmChangeWorkerAddressMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function getPeerId(bytes memory target) internal returns (MinerTypes.GetPeerIDReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetPeerIDMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetPeerIDReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    function getMultiaddresses(bytes memory target) internal returns (MinerTypes.GetMultiaddrsReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(MinerTypes.GetMultiaddrsMethodNum, target, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.GetMultiaddrsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    /// @param target The miner address (type ID) you want to interact with\n    /// @param params the amount you want to withdraw\n    function withdrawBalance(\n        bytes memory target,\n        MinerTypes.WithdrawBalanceParams memory params\n    ) internal returns (MinerTypes.WithdrawBalanceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MinerTypes.WithdrawBalanceMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MinerTypes.WithdrawBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/MultisigAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MultisigTypes.sol\";\nimport \"./cbor/MultisigCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the Multisig actor. Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MultisigAPI {\n    using BytesCBOR for bytes;\n    using ProposeCBOR for MultisigTypes.ProposeParams;\n    using ProposeCBOR for MultisigTypes.ProposeReturn;\n    using TxnIDCBOR for MultisigTypes.TxnIDParams;\n    using ApproveCBOR for MultisigTypes.ApproveReturn;\n    using AddSignerCBOR for MultisigTypes.AddSignerParams;\n    using RemoveSignerCBOR for MultisigTypes.RemoveSignerParams;\n    using SwapSignerCBOR for MultisigTypes.SwapSignerParams;\n    using ChangeNumApprovalsThresholdCBOR for MultisigTypes.ChangeNumApprovalsThresholdParams;\n    using LockBalanceCBOR for MultisigTypes.LockBalanceParams;\n\n    /// @notice TODO fill me up\n    function propose(bytes memory target, MultisigTypes.ProposeParams memory params) internal returns (MultisigTypes.ProposeReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.ProposeMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MultisigTypes.ProposeReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    function approve(bytes memory target, MultisigTypes.TxnIDParams memory params) internal returns (MultisigTypes.ApproveReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.ApproveMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MultisigTypes.ApproveReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice TODO fill me up\n    function cancel(bytes memory target, MultisigTypes.TxnIDParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.CancelMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function addSigner(bytes memory target, MultisigTypes.AddSignerParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.AddSignerMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function removeSigner(bytes memory target, MultisigTypes.RemoveSignerParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.RemoveSignerMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function swapSigner(bytes memory target, MultisigTypes.SwapSignerParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.SwapSignerMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function changeNumApprovalsThreshold(bytes memory target, MultisigTypes.ChangeNumApprovalsThresholdParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.ChangeNumApprovalsThresholdMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function lockBalance(bytes memory target, MultisigTypes.LockBalanceParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.LockBalanceMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n\n    /// @notice TODO fill me up\n    function universalReceiverHook(bytes memory target, bytes memory params) internal {\n        bytes memory raw_request = params.serializeBytes();\n\n        bytes memory raw_response = Actor.call(MultisigTypes.UniversalReceiverHookMethodNum, target, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/PowerAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/PowerTypes.sol\";\nimport \"./cbor/PowerCbor.sol\";\n\nimport \"./utils/Actor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary PowerAPI {\n    using CreateMinerCBOR for PowerTypes.CreateMinerParams;\n    using CreateMinerCBOR for PowerTypes.CreateMinerReturn;\n    using MinerCountCBOR for PowerTypes.MinerCountReturn;\n    using MinerConsensusCountCBOR for PowerTypes.MinerConsensusCountReturn;\n    using NetworkRawPowerCBOR for PowerTypes.NetworkRawPowerReturn;\n    using MinerRawPowerCBOR for PowerTypes.MinerRawPowerParams;\n    using MinerRawPowerCBOR for PowerTypes.MinerRawPowerReturn;\n\n    function createMiner(PowerTypes.CreateMinerParams memory params) internal returns (PowerTypes.CreateMinerReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(PowerTypes.CreateMinerMethodNum, PowerTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        PowerTypes.CreateMinerReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function minerCount() internal returns (PowerTypes.MinerCountReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(PowerTypes.MinerCountMethodNum, PowerTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        PowerTypes.MinerCountReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function minerConsensusCount() internal returns (PowerTypes.MinerConsensusCountReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(PowerTypes.MinerConsensusCountMethodNum, PowerTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        PowerTypes.MinerConsensusCountReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function networkRawPower() internal returns (PowerTypes.NetworkRawPowerReturn memory) {\n        bytes memory raw_request = new bytes(0);\n\n        bytes memory raw_response = Actor.call(PowerTypes.NetworkRawPowerMethodNum, PowerTypes.ActorCode, raw_request, Misc.NONE_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        PowerTypes.NetworkRawPowerReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function minerRawPower(PowerTypes.MinerRawPowerParams memory params) internal returns (PowerTypes.MinerRawPowerReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(PowerTypes.MinerRawPowerMethodNum, PowerTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        PowerTypes.MinerRawPowerReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/PrecompilesAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title This library simplify the call of FEVM precompiles contracts.\n/// @author Zondax AG\nlibrary PrecompilesAPI {\n    uint64 constant GAS_LIMIT = 100000000;\n    uint64 constant MAX_RAW_RESPONSE_SIZE = 0x300;\n\n    function resolveAddress(bytes memory addr) internal view returns (bytes memory) {\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\n        uint len;\n\n        assembly {\n            len := mload(addr)\n            let input := mload(0x40)\n            mstore(input, len)\n            let offset := 0\n            for {\n                offset := 0x00\n            } lt(offset, len) {\n                offset := add(offset, 0x20)\n            } {\n                mstore(add(input, add(0x20, offset)), mload(add(addr, add(0x20, offset))))\n            }\n\n            if iszero(staticcall(GAS_LIMIT, 0x0a, input, add(0x20, len), raw_response, MAX_RAW_RESPONSE_SIZE)) {\n                revert(0, 0)\n            }\n        }\n        return raw_response;\n    }\n\n    function lookupAddress(uint64 actor_id) internal view returns (bytes memory) {\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\n        uint len;\n\n        assembly {\n            len := mload(actor_id)\n            let input := mload(0x40)\n            mstore(input, actor_id)\n\n            if iszero(staticcall(GAS_LIMIT, 0x0b, input, len, raw_response, MAX_RAW_RESPONSE_SIZE)) {\n                revert(0, 0)\n            }\n        }\n        return raw_response;\n    }\n\n    function getActorType(uint64 actor_id) internal view returns (bytes memory) {\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\n        uint len;\n\n        assembly {\n            len := mload(actor_id)\n            let input := mload(0x40)\n            mstore(input, actor_id)\n\n            if iszero(staticcall(GAS_LIMIT, 0x0c, input, len, raw_response, MAX_RAW_RESPONSE_SIZE)) {\n                revert(0, 0)\n            }\n        }\n        return raw_response;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/AccountTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin account actor types for Solidity.\n/// @author Zondax AG\nlibrary AccountTypes {\n    uint constant AuthenticateMessageMethodNum = 2643134072;\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\n\n    struct AuthenticateMessageParams {\n        bytes signature;\n        bytes message;\n    }\n\n    struct UniversalReceiverParams {\n        /// Asset type\n        uint32 type_;\n        /// Payload corresponding to asset type\n        bytes payload;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    enum RegisteredSealProof {\n        StackedDRG2KiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        StackedDRG2KiBV1P1,\n        StackedDRG512MiBV1P1,\n        StackedDRG8MiBV1P1,\n        StackedDRG32GiBV1P1,\n        StackedDRG64GiBV1P1,\n        Invalid\n    }\n\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n\n    enum RegisteredUpdateProof {\n        StackedDRG2KiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        Invalid\n    }\n    enum ExtensionKind {\n        ExtendCommittmentLegacy,\n        ExtendCommittment\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n\n    struct ValidatedExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct ExtendExpirationsInner {\n        ValidatedExpirationExtension[] extensions;\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\n    }\n\n    struct PendingBeneficiaryChange {\n        bytes new_beneficiary;\n        BigInt new_quota;\n        uint64 new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    struct BeneficiaryTerm {\n        BigInt quota;\n        BigInt used_quota;\n        uint64 expiration;\n    }\n\n    struct ActiveBeneficiary {\n        bytes beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    struct RecoveryDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct FaultDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct TerminationDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct SectorClaim {\n        uint64 sector_number;\n        uint64[] maintain_claims;\n        uint64[] drop_claims;\n    }\n\n    struct ExpirationExtension2 {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        SectorClaim[] sectors_with_claims;\n        int64 new_expiration;\n    }\n\n    struct ExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct SectorPreCommitInfoInner {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n\n    struct SectorPreCommitInfo {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n    struct ReplicaUpdateInner {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64[] deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate2 {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct PoStPartition {\n        uint64 index;\n        int8 skipped;\n    }\n\n    struct PoStProof {\n        RegisteredPoStProof post_proof;\n        bytes proof_bytes;\n    }\n\n    struct VestingFunds {\n        int64 epoch;\n        BigInt amount;\n    }\n    struct SectorDeals {\n        int64 sector_type;\n        int64 sector_expiry;\n        uint64[] deal_ids;\n    }\n\n    struct DealProposal {\n        bytes piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        bytes client;\n        bytes provider;\n        string label;\n        int64 start_epoch;\n        int64 end_epoch;\n        BigInt storage_price_per_epoch;\n        BigInt provider_collateral;\n        BigInt client_collateral;\n    }\n\n    struct ClientDealProposal {\n        DealProposal proposal;\n        bytes client_signature;\n    }\n\n    struct SectorDealData {\n        bytes commd;\n    }\n\n    struct CID {\n        uint8 version;\n        uint64 codec;\n        Multihash hash;\n    }\n\n    struct Multihash {\n        uint64 code;\n        uint8 size;\n        bytes digest;\n    }\n\n    struct VerifiedDealInfo {\n        uint64 client;\n        uint64 allocation_id;\n        bytes data;\n        uint64 size;\n    }\n\n    struct SectorDataSpec {\n        uint64[] deal_ids;\n        int64 sector_type;\n    }\n\n    struct FailCode {\n        uint32 idx;\n        uint32 code;\n    }\n\n    struct BatchReturn {\n        // Total successes in batch\n        uint32 success_count;\n        // Failure code and index for each failure in batch\n        FailCode[] fail_codes;\n    }\n\n    struct Claim {\n        // The provider storing the data (from allocation).\n        uint64 provider;\n        // The client which allocated the DataCap (from allocation).\n        uint64 client;\n        // Identifier of the data committed (from allocation).\n        bytes data;\n        // The (padded) size of data (from allocation).\n        uint64 size;\n        // The min period after term_start which the provider must commit to storing data\n        int64 term_min;\n        // The max period after term_start for which provider can earn QA-power for the data\n        int64 term_max;\n        // The epoch at which the (first range of the) piece was committed.\n        int64 term_start;\n        // ID of the provider's sector in which the data is committed.\n        uint64 sector;\n    }\n    struct ClaimTerm {\n        uint64 provider;\n        uint64 claim_id;\n        int64 term_max;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/DataCapTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title Filecoin datacap actor types for Solidity.\n/// @author Zondax AG\nlibrary DataCapTypes {\n    bytes constant ActorCode = hex\"0007\";\n    uint constant NameMethodNum = 48890204;\n    uint constant SymbolMethodNum = 2061153854;\n    uint constant TotalSupplyMethodNum = 114981429;\n    uint constant BalanceOfMethodNum = 3261979605;\n    uint constant TransferMethodNum = 80475954;\n    uint constant TransferFromMethodNum = 3621052141;\n    uint constant IncreaseAllowanceMethodNum = 1777121560;\n    uint constant DecreaseAllowanceMethodNum = 1529376545;\n    uint constant RevokeAllowanceMethodNum = 2765635761;\n    uint constant BurnMethodNum = 1434719642;\n    uint constant BurnFromMethodNum = 2979674018;\n    uint constant AllowanceMethodNum = 4205072950;\n    uint constant ReceiverHookMethodNum = 3726118371;\n\n    struct GetAllowanceParams {\n        bytes owner;\n        bytes operator;\n    }\n\n    struct TransferParams {\n        bytes to;\n        /// A non-negative amount to transfer\n        BigInt amount;\n        /// Arbitrary data to pass on via the receiver hook\n        bytes operator_data;\n    }\n\n    struct TransferReturn {\n        BigInt from_balance;\n        /// The new balance of the `to` address\n        BigInt to_balance;\n        /// (Optional) data returned from receiver hook\n        bytes recipient_data;\n    }\n\n    struct TransferFromParams {\n        bytes from;\n        bytes to;\n        /// A non-negative amount to transfer\n        BigInt amount;\n        /// Arbitrary data to pass on via the receiver hook\n        bytes operator_data;\n    }\n\n    struct TransferFromReturn {\n        BigInt from_balance;\n        /// The new balance of the `to` address\n        BigInt to_balance;\n        /// The new remaining allowance between `owner` and `operator` (caller)\n        BigInt allowance;\n        /// (Optional) data returned from receiver hook\n        bytes recipient_data;\n    }\n\n    struct IncreaseAllowanceParams {\n        bytes operator;\n        /// A non-negative amount to increase the allowance by\n        BigInt increase;\n    }\n    struct DecreaseAllowanceParams {\n        bytes operator;\n        /// A non-negative amount to decrease the allowance by\n        BigInt decrease;\n    }\n    struct RevokeAllowanceParams {\n        bytes operator;\n    }\n\n    struct BurnParams {\n        /// A non-negative amount to burn\n        BigInt amount;\n    }\n\n    struct BurnReturn {\n        /// New balance in the account after the successful burn\n        BigInt balance;\n    }\n\n    struct BurnFromParams {\n        bytes owner;\n        /// A non-negative amount to burn\n        BigInt amount;\n    }\n\n    struct BurnFromReturn {\n        /// New balance in the account after the successful burn\n        BigInt balance;\n        /// New remaining allowance between the owner and operator (caller)\n        BigInt allowance;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/InitTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n/// @title Filecoin init actor types for Solidity.\n/// @author Zondax AG\nlibrary InitTypes {\n    bytes constant ActorCode = hex\"0001\";\n    uint constant ExecMethodNum = 81225168;\n    uint constant Exec4MethodNum = 3;\n\n    struct ExecParams {\n        bytes code_cid;\n        bytes constructor_params;\n    }\n\n    struct ExecReturn {\n        /// ID based address for created actor\n        bytes id_address;\n        /// Reorg safe address for actor\n        bytes robust_address;\n    }\n\n    struct Exec4Params {\n        bytes code_cid;\n        bytes constructor_params;\n        bytes subaddress;\n    }\n\n    struct Exec4Return {\n        /// ID based address for created actor\n        bytes id_address;\n        /// Reorg safe address for actor\n        bytes robust_address;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    bytes constant ActorCode = hex\"0005\";\n    uint constant AddBalanceMethodNum = 822473126;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n    uint constant GetBalanceMethodNum = 726108461;\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\n    uint constant GetDealClientMethodNum = 128053329;\n    uint constant GetDealProviderMethodNum = 935081690;\n    uint constant GetDealLabelMethodNum = 46363526;\n    uint constant GetDealTermMethodNum = 163777312;\n    uint constant GetDealEpochPriceMethodNum = 4287162428;\n    uint constant GetDealClientCollateralMethodNum = 200567895;\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\n    uint constant GetDealVerifiedMethodNum = 2627389465;\n    uint constant GetDealActivationMethodNum = 2567238399;\n    uint constant PublishStorageDealsMethodNum = 2236929350;\n\n    struct WithdrawBalanceParams {\n        bytes provider_or_client;\n        BigInt tokenAmount;\n    }\n\n    struct WithdrawBalanceReturn {\n        BigInt amount_withdrawn;\n    }\n\n    struct GetBalanceReturn {\n        BigInt balance;\n        BigInt locked;\n    }\n\n    struct GetDealDataCommitmentParams {\n        uint64 id;\n    }\n\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    struct GetDealClientParams {\n        uint64 id;\n    }\n\n    struct GetDealClientReturn {\n        uint64 client;\n    }\n\n    struct GetDealProviderParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderReturn {\n        uint64 provider;\n    }\n\n    struct GetDealLabelParams {\n        uint64 id;\n    }\n\n    struct GetDealLabelReturn {\n        string label;\n    }\n\n    struct GetDealTermParams {\n        uint64 id;\n    }\n\n    struct GetDealTermReturn {\n        int64 start;\n        int64 end;\n    }\n\n    struct GetDealEpochPriceParams {\n        uint64 id;\n    }\n\n    struct GetDealEpochPriceReturn {\n        BigInt price_per_epoch;\n    }\n\n    struct GetDealClientCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealClientCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealProviderCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealVerifiedParams {\n        uint64 id;\n    }\n\n    struct GetDealVerifiedReturn {\n        bool verified;\n    }\n\n    struct GetDealActivationParams {\n        uint64 id;\n    }\n\n    struct GetDealActivationReturn {\n        int64 activated;\n        int64 terminated;\n    }\n\n    struct PublishStorageDealsParams {\n        CommonTypes.ClientDealProposal[] deals;\n    }\n\n    struct PublishStorageDealsReturn {\n        uint64[] ids;\n        bytes valid_deals;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/MinerTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin miner actor types for Solidity.\n/// @author Zondax AG\nlibrary MinerTypes {\n    uint constant GetOwnerMethodNum = 3275365574;\n    uint constant ChangeOwnerAddressMethodNum = 1010589339;\n    uint constant IsControllingAddressMethodNum = 348244887;\n    uint constant GetSectorSizeMethodNum = 3858292296;\n    uint constant GetAvailableBalanceMethodNum = 4026106874;\n    uint constant GetVestingFundsMethodNum = 1726876304;\n    uint constant ChangeBeneficiaryMethodNum = 1570634796;\n    uint constant GetBeneficiaryMethodNum = 4158972569;\n    uint constant ChangeWorkerAddressMethodNum = 3302309124;\n    uint constant ChangePeerIDMethodNum = 1236548004;\n    uint constant ChangeMultiaddrsMethodNum = 1063480576;\n    uint constant RepayDebtMethodNum = 3665352697;\n    uint constant ConfirmChangeWorkerAddressMethodNum = 2354970453;\n    uint constant GetPeerIDMethodNum = 2812875329;\n    uint constant GetMultiaddrsMethodNum = 1332909407;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n\n    struct GetOwnerReturn {\n        bytes owner;\n        bytes proposed;\n    }\n\n    struct IsControllingAddressParam {\n        bytes addr;\n    }\n\n    struct IsControllingAddressReturn {\n        bool is_controlling;\n    }\n\n    struct GetSectorSizeReturn {\n        uint64 sector_size;\n    }\n    struct GetAvailableBalanceReturn {\n        BigInt available_balance;\n    }\n\n    struct GetVestingFundsReturn {\n        CommonTypes.VestingFunds[] vesting_funds;\n    }\n\n    struct ChangeBeneficiaryParams {\n        bytes new_beneficiary;\n        BigInt new_quota;\n        uint64 new_expiration;\n    }\n\n    struct GetBeneficiaryReturn {\n        CommonTypes.ActiveBeneficiary active;\n        CommonTypes.PendingBeneficiaryChange proposed;\n    }\n\n    struct ChangeWorkerAddressParams {\n        bytes new_worker;\n        bytes[] new_control_addresses;\n    }\n\n    struct ChangePeerIDParams {\n        bytes new_id;\n    }\n\n    struct ChangeMultiaddrsParams {\n        bytes[] new_multi_addrs;\n    }\n\n    struct GetPeerIDReturn {\n        bytes peer_id;\n    }\n\n    struct GetMultiaddrsReturn {\n        bytes[] multi_addrs;\n    }\n\n    struct WithdrawBalanceParams {\n        bytes amount_requested;\n    }\n\n    struct WithdrawBalanceReturn {\n        bytes amount_withdrawn;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/MultisigTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin multisig actor types for Solidity.\n/// @author Zondax AG\nlibrary MultisigTypes {\n    uint constant ProposeMethodNum = 1696838335;\n    uint constant ApproveMethodNum = 1289044053;\n    uint constant CancelMethodNum = 3365893656;\n    uint constant AddSignerMethodNum = 3028530033;\n    uint constant RemoveSignerMethodNum = 21182899;\n    uint constant SwapSignerMethodNum = 3968117037;\n    uint constant ChangeNumApprovalsThresholdMethodNum = 3375931653;\n    uint constant LockBalanceMethodNum = 1999470977;\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\n\n    struct ProposeParams {\n        bytes to;\n        BigInt value;\n        uint64 method;\n        bytes params;\n    }\n\n    struct ProposeReturn {\n        /// TxnID is the ID of the proposed transaction.\n        int64 txn_id;\n        /// Applied indicates if the transaction was applied as opposed to proposed but not applied\n        /// due to lack of approvals.\n        bool applied;\n        /// Code is the exitcode of the transaction, if Applied is false this field should be ignored.\n        uint32 code;\n        /// Ret is the return value of the transaction, if Applied is false this field should\n        /// be ignored.\n        bytes ret;\n    }\n\n    struct TxnIDParams {\n        int64 id;\n        /// Optional hash of proposal to ensure an operation can only apply to a\n        /// specific proposal.\n        bytes proposal_hash;\n    }\n\n    struct ApproveReturn {\n        /// Applied indicates if the transaction was applied as opposed to proposed but not applied\n        /// due to lack of approvals\n        bool applied;\n        /// Code is the exitcode of the transaction, if Applied is false this field should be ignored.\n        uint32 code;\n        /// Ret is the return value of the transaction, if Applied is false this field should\n        /// be ignored.\n        bytes ret;\n    }\n\n    struct AddSignerParams {\n        bytes signer;\n        bool increase;\n    }\n\n    struct RemoveSignerParams {\n        bytes signer;\n        bool decrease;\n    }\n\n    struct SwapSignerParams {\n        bytes from;\n        bytes to;\n    }\n\n    struct ChangeNumApprovalsThresholdParams {\n        uint64 new_threshold;\n    }\n\n    struct LockBalanceParams {\n        int64 start_epoch;\n        int64 unlock_duration;\n        BigInt amount;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/PowerTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin power actor types for Solidity.\n/// @author Zondax AG\nlibrary PowerTypes {\n    bytes constant ActorCode = hex\"0004\";\n    uint constant CreateMinerMethodNum = 1173380165;\n    uint constant MinerCountMethodNum = 1987646258;\n    uint constant MinerConsensusCountMethodNum = 196739875;\n    uint constant NetworkRawPowerMethodNum = 931722534;\n    uint constant MinerRawPowerMethodNum = 3753401894;\n\n    struct CreateMinerParams {\n        bytes owner;\n        bytes worker;\n        CommonTypes.RegisteredPoStProof window_post_proof_type;\n        bytes peer;\n        bytes[] multiaddrs;\n    }\n    struct CreateMinerReturn {\n        /// Canonical ID-based address for the actor.\n        bytes id_address;\n        /// Re-org safe address for created actor.\n        bytes robust_address;\n    }\n    struct MinerCountReturn {\n        uint64 miner_count;\n    }\n    struct MinerConsensusCountReturn {\n        int64 miner_consensus_count;\n    }\n    struct NetworkRawPowerReturn {\n        BigInt raw_byte_power;\n    }\n    struct MinerRawPowerParams {\n        uint64 miner;\n    }\n    struct MinerRawPowerReturn {\n        BigInt raw_byte_power;\n        bool meets_consensus_minimum;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/types/VerifRegTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin Verified Registry actor types for Solidity.\n/// @author Zondax AG\nlibrary VerifRegTypes {\n    bytes constant ActorCode = hex\"0006\";\n    uint constant GetClaimsMethodNum = 2199871187;\n    uint constant AddVerifierClientMethodNum = 3916220144;\n    uint constant RemoveExpiredAllocationsMethodNum = 2421068268;\n    uint constant ExtendClaimTermsMethodNum = 1752273514;\n    uint constant RemoveExpiredClaimsMethodNum = 2873373899;\n    uint constant UniversalReceiverMethodNum = 3726118371;\n\n    struct GetClaimsParams {\n        uint64 provider;\n        uint64[] claim_ids;\n    }\n    struct GetClaimsReturn {\n        CommonTypes.BatchReturn batch_info;\n        CommonTypes.Claim[] claims;\n    }\n    struct AddVerifierClientParams {\n        bytes addr;\n        bytes allowance;\n    }\n    struct RemoveExpiredAllocationsParams {\n        // Client for which to remove expired allocations.\n        uint64 client;\n        // Optional list of allocation IDs to attempt to remove.\n        // Empty means remove all eligible expired allocations.\n        uint64[] allocation_ids;\n    }\n    struct RemoveExpiredAllocationsReturn {\n        // Ids of the allocations that were either specified by the caller or discovered to be expired.\n        uint64[] considered;\n        // Results for each processed allocation.\n        CommonTypes.BatchReturn results;\n        // The amount of datacap reclaimed for the client.\n        BigInt datacap_recovered;\n    }\n    struct RemoveExpiredClaimsParams {\n        // Provider to clean up (need not be the caller)\n        uint64 provider;\n        // Optional list of claim IDs to attempt to remove.\n        // Empty means remove all eligible expired claims.\n        uint64[] claim_ids;\n    }\n    struct RemoveExpiredClaimsReturn {\n        // Ids of the claims that were either specified by the caller or discovered to be expired.\n        uint64[] considered;\n        // Results for each processed claim.\n        CommonTypes.BatchReturn results;\n    }\n    struct ExtendClaimTermsParams {\n        CommonTypes.ClaimTerm[] terms;\n    }\n    struct UniversalReceiverParams {\n        /// Asset type\n        uint32 type_;\n        /// Payload corresponding to asset type\n        bytes payload;\n    }\n\n    struct AllocationsResponse {\n        // Result for each allocation request.\n        CommonTypes.BatchReturn allocation_results;\n        // Result for each extension request.\n        CommonTypes.BatchReturn extension_results;\n        // IDs of new allocations created.\n        uint64[] new_allocations;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/Utils.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./types/AccountTypes.sol\";\nimport \"./types/DataCapTypes.sol\";\nimport \"./cbor/AccountCbor.sol\";\n\n/// @title This library compiles a bunch of help function.\n/// @author Zondax AG\nlibrary Utils {\n    using AuthenticateMessageCBOR for AccountTypes.AuthenticateMessageParams;\n    using BytesCBOR for bytes;\n\n    event ReceivedDataCap(string received);\n\n    function handleFilecoinMethod(\n        uint64 method,\n        uint64,\n        bytes calldata params\n    ) internal returns (AccountTypes.AuthenticateMessageParams memory) {\n        AccountTypes.AuthenticateMessageParams memory response;\n        // dispatch methods\n        if (method == AccountTypes.AuthenticateMessageMethodNum) {\n            // deserialize params here\n            response.deserialize(params);\n\n            return response;\n        } else if (method == DataCapTypes.ReceiverHookMethodNum) {\n            emit ReceivedDataCap(\"DataCap Received!\");\n\n            return response;\n        } else {\n            revert(\"the filecoin method that was called is not handled\");\n        }\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/utils/Actor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../../../../openzeppelin-contracts/contracts/utils/Strings.sol\";\n\nimport \"./Misc.sol\";\n\nlibrary HyperActor {\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    function convert (uint256 _a) internal returns (uint64) \n    {\n        return uint64(_a);\n    }\n\n    function call_actor_id(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, uint64 id) internal returns (bool, int256, uint64, bytes memory) {\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(abi.encode(method, value, flags, codec, params, id));\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\n        return (success, exit, return_codec, return_value);\n    }\n\n    function call_actor_address(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, bytes memory filAddress) internal returns (bool, int256, uint64, bytes memory) {\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(abi.encode(method, value, flags, codec, params, filAddress));\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\n        return (success, exit, return_codec, return_value);\n    }\n\n    function call(uint method, bytes memory filAddress, bytes memory params, uint64 codec) internal returns (bytes memory) {\n        return call_inner(convert(method), filAddress, params, codec, msg.value);\n    }\n\n    function call_inner(uint method, bytes memory filAddress, bytes memory params, uint64 codec, uint amount) internal returns (bytes memory ) {\n        (bool _success, int256 exit_code, uint64 _return_codec, bytes memory return_value) = call_actor_address(convert(method), amount, DEFAULT_FLAG, codec, params, filAddress);\n        require(exit_code == 0, string.concat(\"actor error code \", Strings.toString(exit_code)));\n        return return_value;\n    }\n}\n\n\n\nlibrary Actor {\n    uint64 constant GAS_LIMIT = 100000000;\n    uint64 constant CALL_ACTOR_PRECOMPILE_ADDR = 0x0e;\n    uint64 constant MAX_RAW_RESPONSE_SIZE = 0x300;\n    uint64 constant READ_ONLY_FLAG = 0x00000001; // https://github.com/filecoin-project/ref-fvm/blob/master/shared/src/sys/mod.rs#L60\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    function call(uint method_num, bytes memory actor_code, bytes memory raw_request, uint64 codec) internal returns (bytes memory) {\n        call_inner(method_num, actor_code, raw_request, codec, msg.value);\n    }\n\n    function call_inner(uint method_num, bytes memory actor_code, bytes memory raw_request, uint64 codec, uint amount) internal returns (bytes memory) {\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\n\n        uint raw_request_len;\n        uint actor_code_len;\n\n        assembly {\n            raw_request_len := mload(raw_request)\n            actor_code_len := mload(actor_code)\n\n            let input := mload(0x40)\n            mstore(input, method_num)\n            // value to send\n            mstore(add(input, 0x20), amount)\n            // readonly flag is mandatory for now\n            mstore(add(input, 0x40), DEFAULT_FLAG)\n            // cbor codec is mandatory for now\n            mstore(add(input, 0x60), codec)\n            // params size\n            mstore(add(input, 0x80), raw_request_len)\n            // address size\n            mstore(add(input, 0xa0), actor_code_len)\n            // actual params (copy by slice of 32 bytes)\n            let start_index := 0xc0\n            let offset := 0\n            for {\n                offset := 0x00\n            } lt(offset, raw_request_len) {\n                offset := add(offset, 0x20)\n            } {\n                mstore(add(input, add(start_index, offset)), mload(add(raw_request, add(0x20, offset))))\n            }\n            if mod(raw_request_len, 0x20) {\n                offset := add(sub(offset, 0x20), mod(raw_request_len, 0x20))\n            }\n\n            // actual address (copy by slice of 32 bytes)\n            start_index := add(start_index, offset)\n            offset := 0\n            for {\n                offset := 0x00\n            } lt(offset, actor_code_len) {\n                offset := add(offset, 0x20)\n            } {\n                mstore(add(input, add(start_index, offset)), mload(add(actor_code, add(0x20, offset))))\n            }\n            if mod(actor_code_len, 0x20) {\n                offset := add(sub(offset, 0x20), mod(actor_code_len, 0x20))\n            }\n\n            let len := add(start_index, offset)\n\n            // FIXME set inputSize according to the input length\n            // delegatecall(gasLimit, to, inputOffset, inputSize, outputOffset, outputSize)\n            if iszero(delegatecall(GAS_LIMIT, CALL_ACTOR_PRECOMPILE_ADDR, input, len, raw_response, MAX_RAW_RESPONSE_SIZE)) {\n                revert(0, 0)\n            }\n        }\n\n        return raw_response;\n    }\n\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\n        uint256 exit_code = Misc.toUint256(raw_response, 0x00);\n        uint256 size = Misc.toUint256(raw_response, 0x60);\n        require(exit_code == 0, string.concat(\"actor error code \", Strings.toString(exit_code)));\n\n        bytes memory result = new bytes(size);\n        uint src;\n        uint dst;\n        assembly {\n            src := add(raw_response, 0x80)\n            dst := add(result, 0x20)\n        }\n        Misc.copy(src, dst, size);\n\n        return result;\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n// \tMajUnsignedInt = 0\n// \tMajSignedInt   = 1\n// \tMajByteString  = 2\n// \tMajTextString  = 3\n// \tMajArray       = 4\n// \tMajMap         = 5\n// \tMajTag         = 6\n// \tMajOther       = 7\n\nuint8 constant MajUnsignedInt = 0;\nuint8 constant MajSignedInt = 1;\nuint8 constant MajByteString = 2;\nuint8 constant MajTextString = 3;\nuint8 constant MajArray = 4;\nuint8 constant MajMap = 5;\nuint8 constant MajTag = 6;\nuint8 constant MajOther = 7;\n\nuint8 constant TagTypeBigNum = 2;\nuint8 constant TagTypeNegativeBigNum = 3;\n\nuint8 constant True_Type = 21;\nuint8 constant False_Type = 20;\n\nlibrary CBORDecoder {\n    function isNullNext(bytes memory cborParams, uint byteIdx) internal pure returns (bool) {\n        return cborParams[byteIdx] == hex\"f6\";\n    }\n\n    function readBool(bytes memory cborParams, uint byteIdx) internal pure returns (bool, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajOther);\n        assert(value == True_Type || value == False_Type);\n\n        return (value != False_Type, byteIdx);\n    }\n\n    function readFixedArray(bytes memory cborParams, uint byteIdx) internal pure returns (uint, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajArray);\n\n        return (len, byteIdx);\n    }\n\n    function readString(bytes memory cborParams, uint byteIdx) internal pure returns (string memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTextString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (string(slice), byteIdx + len);\n    }\n\n    function readBytes(bytes memory cborParams, uint byteIdx) internal pure returns (bytes memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajByteString);\n\n        if (maj == MajTag) {\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n        }\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (slice, byteIdx + len);\n    }\n\n    function readBytes32(bytes memory cborParams, uint byteIdx) internal pure returns (bytes32, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajByteString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(32);\n        uint slice_index = 32 - len;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (bytes32(slice), byteIdx + len);\n    }\n\n    function readUInt256(bytes memory cborParams, uint byteIdx) internal pure returns (uint256, uint) {\n        uint8 maj;\n        uint256 value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajUnsignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (value, byteIdx + len);\n        }\n\n        return (value, byteIdx);\n    }\n\n    function readInt256(bytes memory cborParams, uint byteIdx) internal pure returns (int256, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajSignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeNegativeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (int256(value), byteIdx + len);\n        }\n\n        return (int256(value), byteIdx);\n    }\n\n    function readUInt64(bytes memory cborParams, uint byteIdx) internal pure returns (uint64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint64(value), byteIdx);\n    }\n\n    function readUInt32(bytes memory cborParams, uint byteIdx) internal pure returns (uint32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint32(value), byteIdx);\n    }\n\n    function readUInt16(bytes memory cborParams, uint byteIdx) internal pure returns (uint16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint16(value), byteIdx);\n    }\n\n    function readUInt8(bytes memory cborParams, uint byteIdx) internal pure returns (uint8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint8(value), byteIdx);\n    }\n\n    function readInt64(bytes memory cborParams, uint byteIdx) internal pure returns (int64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int64(uint64(value)), byteIdx);\n    }\n\n    function readInt32(bytes memory cborParams, uint byteIdx) internal pure returns (int32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int32(uint32(value)), byteIdx);\n    }\n\n    function readInt16(bytes memory cborParams, uint byteIdx) internal pure returns (int16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int16(uint16(value)), byteIdx);\n    }\n\n    function readInt8(bytes memory cborParams, uint byteIdx) internal pure returns (int8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int8(uint8(value)), byteIdx);\n    }\n\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\n        require(bs.length >= start + 1, \"slicing out of range\");\n        uint8 x;\n        assembly {\n            x := mload(add(bs, add(0x01, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\n        require(bs.length >= start + 2, \"slicing out of range\");\n        uint16 x;\n        assembly {\n            x := mload(add(bs, add(0x02, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\n        require(bs.length >= start + 4, \"slicing out of range\");\n        uint32 x;\n        assembly {\n            x := mload(add(bs, add(0x04, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\n        require(bs.length >= start + 8, \"slicing out of range\");\n        uint64 x;\n        assembly {\n            x := mload(add(bs, add(0x08, start)))\n        }\n        return x;\n    }\n\n    // Parse cbor header for major type and extra info.\n    // Also return the byte index after moving past header bytes, and the number of bytes consumed\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\n        uint8 first = sliceUInt8(cbor, byteIndex);\n        byteIndex += 1;\n        uint8 maj = (first & 0xe0) >> 5;\n        uint8 low = first & 0x1f;\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\n        assert(low < 28);\n\n        // extra is lower bits\n        if (low < 24) {\n            return (maj, low, byteIndex);\n        }\n\n        // extra in next byte\n        if (low == 24) {\n            uint8 next = sliceUInt8(cbor, byteIndex);\n            byteIndex += 1;\n            assert(next >= 24); // otherwise this is invalid cbor\n            return (maj, next, byteIndex);\n        }\n\n        // extra in next 2 bytes\n        if (low == 25) {\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\n            byteIndex += 2;\n            return (maj, extra16, byteIndex);\n        }\n\n        // extra in next 4 bytes\n        if (low == 26) {\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\n            byteIndex += 4;\n            return (maj, extra32, byteIndex);\n        }\n\n        // extra in next 8 bytes\n        assert(low == 27);\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\n        byteIndex += 8;\n        return (maj, extra64, byteIndex);\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/utils/Misc.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nlibrary Misc {\n    uint64 constant CBOR_CODEC = 0x71;\n    uint64 constant NONE_CODEC = 0x00;\n\n    function toUint256(bytes32 _bytes) internal pure returns (uint256 value) {\n        return uint256(_bytes);\n    }\n\n    function toInt256(bytes32 _bytes) internal pure returns (int256 value) {\n        return int256(uint256(_bytes));\n    }\n\n    function toUint256(bytes memory _bytes, uint offset) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(_bytes, offset))\n        }\n    }\n\n    function toInt256(bytes memory _bytes, uint offset) internal pure returns (int256 value) {\n        return int256(toUint256(_bytes, offset));\n    }\n\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function toBytes(int256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function copy(uint src, uint dest, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        if (len == 0) return;\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/lib/filecoin-solidity/contracts/v0.8/VerifRegAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/VerifRegTypes.sol\";\nimport \"./cbor/VerifRegCbor.sol\";\n\nimport \"./utils/Actor.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary VerifRegAPI {\n    using GetClaimsCBOR for VerifRegTypes.GetClaimsParams;\n    using GetClaimsCBOR for VerifRegTypes.GetClaimsReturn;\n    using AddVerifierClientCBOR for VerifRegTypes.AddVerifierClientParams;\n    using RemoveExpiredAllocationsCBOR for VerifRegTypes.RemoveExpiredAllocationsParams;\n    using RemoveExpiredAllocationsCBOR for VerifRegTypes.RemoveExpiredAllocationsReturn;\n    using ExtendClaimTermsCBOR for VerifRegTypes.ExtendClaimTermsParams;\n    using ExtendClaimTermsCBOR for CommonTypes.BatchReturn;\n    using RemoveExpiredClaimsCBOR for VerifRegTypes.RemoveExpiredClaimsParams;\n    using RemoveExpiredClaimsCBOR for VerifRegTypes.RemoveExpiredClaimsReturn;\n    using UniversalReceiverHookCBOR for VerifRegTypes.UniversalReceiverParams;\n    using UniversalReceiverHookCBOR for VerifRegTypes.AllocationsResponse;\n\n    function getClaims(VerifRegTypes.GetClaimsParams memory params) internal returns (VerifRegTypes.GetClaimsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(VerifRegTypes.GetClaimsMethodNum, VerifRegTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        VerifRegTypes.GetClaimsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function addVerifiedClient(VerifRegTypes.AddVerifierClientParams memory params) internal {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            VerifRegTypes.AddVerifierClientMethodNum,\n            VerifRegTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    function removeExpiredAllocations(\n        VerifRegTypes.RemoveExpiredAllocationsParams memory params\n    ) internal returns (VerifRegTypes.RemoveExpiredAllocationsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            VerifRegTypes.RemoveExpiredAllocationsMethodNum,\n            VerifRegTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        VerifRegTypes.RemoveExpiredAllocationsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function extendClaimTerms(VerifRegTypes.ExtendClaimTermsParams memory params) internal returns (CommonTypes.BatchReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            VerifRegTypes.ExtendClaimTermsMethodNum,\n            VerifRegTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        CommonTypes.BatchReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function removeExpiredClaims(\n        VerifRegTypes.RemoveExpiredClaimsParams memory params\n    ) internal returns (VerifRegTypes.RemoveExpiredClaimsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            VerifRegTypes.RemoveExpiredClaimsMethodNum,\n            VerifRegTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        VerifRegTypes.RemoveExpiredClaimsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    function universalReceiverHook(\n        VerifRegTypes.UniversalReceiverParams memory params\n    ) internal returns (VerifRegTypes.AllocationsResponse memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            VerifRegTypes.UniversalReceiverMethodNum,\n            VerifRegTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        VerifRegTypes.AllocationsResponse memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/lib/solidity-cborutils/contracts/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../buffer/contracts/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "contracts/lib/solidity-cborutils/test/TestCBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.19 < 0.9.0;\n\nimport \"../contracts/CBOR.sol\";\n\ncontract TestCBOR {\n    using CBOR for CBOR.CBORBuffer;\n\n    function getTestData() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        // Maps\n        buf.startMap();\n\n        // Short strings\n        buf.writeKVString(\"key1\", \"value1\");\n\n        // Longer strings\n        buf.writeKVString(\"long\", \"This string is longer than 24 characters.\");\n\n        // Bytes\n        buf.writeKVBytes(\"bytes\", bytes(\"Test\"));\n\n        // Bools, null, undefined\n        buf.writeKVBool(\"true\", true);\n        buf.writeKVBool(\"false\", false);\n        buf.writeKVNull(\"null\");\n        buf.writeKVUndefined(\"undefined\");\n\n        // Arrays\n        buf.writeKVArray(\"array\");\n        buf.writeUInt64(0);\n        buf.writeUInt64(1);\n        buf.writeUInt64(23);\n        buf.writeUInt64(24);\n\n        // 2, 4, and 8 byte numbers.\n        buf.writeUInt64(0x100);\n        buf.writeUInt64(0x10000);\n        buf.writeUInt64(0x100000000);\n\n        // Negative numbers\n        buf.writeInt64(-42);\n\n        buf.endSequence();\n        buf.endSequence();\n\n        return buf.data();\n    }\n\n    function getTestDataBigInt() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(128);\n\n        buf.startArray();\n        buf.writeInt256(type(int256).min);\n        buf.writeInt256(type(int256).min+1);\n        buf.writeInt256(type(int256).max-1);\n        buf.writeInt256(type(int256).max);\n        buf.writeInt64(type(int64).min);\n        buf.writeInt64(type(int64).min+1);\n        buf.writeInt64(type(int64).max-1);\n        buf.writeInt64(type(int64).max);\n        buf.endSequence();\n\n        return buf.data();\n    }\n\n    function getTestDataBigUint() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(128);\n\n        buf.startArray();\n        buf.writeUInt256(type(uint256).min);\n        buf.writeUInt256(type(uint256).min+1);\n        buf.writeUInt256(type(uint256).max-1);\n        buf.writeUInt256(type(uint256).max);\n        buf.endSequence();\n\n        return buf.data();\n    }\n\n    function getTestDataDefiniteLengthArray() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(128);\n\n        uint64 length = 1024;\n        buf.startFixedArray(length);\n        for (uint64 i = 0; i < length; i++) {\n            buf.writeInt64(int64(i));\n        }\n\n        return buf.data();\n    }\n\n    function getTestDataDefiniteLengthMap() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(128);\n\n        buf.startFixedMap(3);\n        buf.writeKVInt64(\"a\", 100);\n        buf.writeKVInt64(\"b\", 200);\n        buf.writeKVInt64(\"c\", 300);\n\n        return buf.data();\n    }\n\n    function getTestDataInvalidCBOR() public pure returns(bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(128);\n\n        buf.startArray();\n        buf.startArray();\n        buf.startArray();\n        buf.writeUInt256(type(uint256).min);\n        buf.endSequence();\n\n        return buf.data(); // this would revert()\n    }\n}\n"
    },
    "solidity-cborutils/contracts/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}